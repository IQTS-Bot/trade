<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IQTS Bot - Intelligent Quantitative Trading System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/notyf/3.10.0/notyf.min.css">
    <style>
        :root {
            --bg-dark: #0a0a12;
            --card-bg: rgba(20, 20, 40, 0.9);
            --accent: #00ffaa;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --positive: #00ffaa;
            --negative: #ff5555;
            --warning: #ffaa00;
            --border: rgba(0, 255, 170, 0.2);
            --gradient: linear-gradient(135deg, #0a0a12, #1a1a2e);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--gradient);
            color: var(--text-primary);
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            overflow-x: hidden;
            min-height: 100vh;
        }

        .app-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header Styles */
        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 25px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 15px;
            margin-bottom: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            border: 2px solid var(--accent);
            box-shadow: 0 0 20px rgba(0, 255, 170, 0.3);
            object-fit: cover;
            display: block;
            background: linear-gradient(45deg, var(--accent), #1a1a2e);
            position: relative;
        }

        .logo::before {
            content: 'IQTS';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--accent);
            font-weight: bold;
            font-size: 12px;
            text-shadow: 0 0 10px var(--accent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .logo:not([src]), .logo[src=""], .logo[src*="error"] {
            background: linear-gradient(45deg, var(--accent), #1a1a2e);
        }

        .logo:not([src])::before, .logo[src=""]::before, .logo[src*="error"]::before {
            opacity: 1;
        }

        .app-title {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(45deg, var(--accent), #ffffff);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 255, 170, 0.5);
        }

        .status-panel {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: rgba(0, 255, 170, 0.1);
            border: 1px solid var(--accent);
            border-radius: 25px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 10px var(--accent); }
            50% { box-shadow: 0 0 20px var(--accent), 0 0 30px var(--accent); }
            100% { box-shadow: 0 0 10px var(--accent); }
        }

        /* Enhanced Visual Indicators */
        .status-bar {
            height: 4px;
            width: 100%;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1000;
            background: var(--accent);
            opacity: 0.7;
            animation: pulseStatus 2s infinite;
        }

        @keyframes pulseStatus {
            0% { opacity: 0.3; }
            50% { opacity: 0.8; }
            100% { opacity: 0.3; }
        }

        .status-bar.active {
            background: var(--positive);
            animation: pulseStatusActive 1.5s infinite;
        }

        @keyframes pulseStatusActive {
            0% { box-shadow: 0 0 5px var(--positive); }
            50% { box-shadow: 0 0 15px var(--positive); }
            100% { box-shadow: 0 0 5px var(--positive); }
        }

        .status-bar.emergency {
            background: var(--negative);
            animation: pulseEmergency 0.5s infinite;
        }

        @keyframes pulseEmergency {
            0% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0.3; }
        }

        /* Grid Layout */
        .main-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            grid-template-rows: auto auto auto;
            gap: 25px;
            margin-bottom: 25px;
        }

        .glassmorphism-card {
            background: var(--card-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--border);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            overflow: visible;
            position: relative;
        }

        .glassmorphism-card:hover {
            border-color: var(--accent);
            box-shadow: 0 12px 40px rgba(0, 255, 170, 0.1);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .card-title {
            font-size: 1.3rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--accent);
        }

        /* Ensure chart and activity content fit properly */
        .chart-container .card-header + *,
        .positions-container .card-header + * {
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        /* Activity container should allow scrolling */
        .activity-container .card-header + * {
            flex: 1;
            min-height: 0;
            overflow: visible;
        }

        /* Chart Container */
        .chart-container {
            grid-column: span 1;
            height: 500px;
            min-height: 400px;
            position: relative;
            overflow: visible;
        }

        /* Activity Indicator */
        .activity-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        .indicator-pulse {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: var(--accent);
            opacity: 0;
            position: absolute;
            animation: indicatorPulse 2s infinite;
        }

        .indicator-icon {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
            font-size: 1.2rem;
        }

        @keyframes indicatorPulse {
            0% { transform: scale(0.8); opacity: 0.7; }
            70% { transform: scale(1.3); opacity: 0; }
            100% { transform: scale(0.8); opacity: 0; }
        }

        .activity-indicator.active .indicator-pulse {
            animation: pulseFast 1s infinite;
            background: var(--positive);
        }

        @keyframes pulseFast {
            0% { transform: scale(0.8); opacity: 0.7; }
            70% { transform: scale(1.5); opacity: 0; }
            100% { transform: scale(0.8); opacity: 0; }
        }

        .activity-indicator.alert .indicator-pulse {
            animation: pulseAlert 0.8s infinite;
            background: var(--negative);
        }

        @keyframes pulseAlert {
            0% { transform: scale(0.8); opacity: 0.9; }
            70% { transform: scale(1.8); opacity: 0; }
            100% { transform: scale(0.8); opacity: 0; }
        }

        .chart-wrapper {
            position: relative;
            height: calc(100% - 140px); /* Account for header and controls */
            width: 100%;
            min-height: 280px;
            z-index: 1;
            margin-top: 10px;
            background-color: #000000;
        }

        #tradingChart {
            width: 100%;
            height: 100%;
            background-color: transparent !important;
            display: block;
        }

        /* Control Panel */
        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .control-buttons {
            display: flex;
            gap: 15px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-start {
            background: linear-gradient(45deg, var(--positive), #00cc88);
            color: #000;
            flex: 1;
        }

        .btn-start:hover {
            box-shadow: 0 8px 25px rgba(0, 255, 170, 0.4);
            transform: translateY(-2px);
        }

        .btn-stop {
            background: linear-gradient(45deg, var(--negative), #cc4444);
            color: #fff;
            flex: 1;
        }

        .btn-stop:hover {
            box-shadow: 0 8px 25px rgba(255, 85, 85, 0.4);
            transform: translateY(-2px);
        }

        .btn-emergency {
            background: radial-gradient(circle, #ff0000, #cc0000);
            color: #fff;
            font-size: 1.1rem;
            padding: 15px;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            margin: 0 auto;
            animation: emergencyPulse 2s infinite;
        }

        @keyframes emergencyPulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        /* Risk Control */
        .risk-control {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid var(--border);
        }

        .risk-slider {
            width: 100%;
            margin: 15px 0;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            box-shadow: 0 0 10px var(--accent);
        }

        /* Positions Grid */
        .positions-container {
            grid-column: span 1;
            height: 400px;
            min-height: 300px;
        }

        .positions-grid {
            display: grid;
            gap: 12px;
            height: calc(100% - 60px); /* Account for header */
            overflow-y: auto;
            padding-right: 5px;
        }

        .positions-grid::-webkit-scrollbar {
            width: 6px;
        }

        .positions-grid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        .positions-grid::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 3px;
        }

        .position-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--accent);
            transition: all 0.3s ease;
        }

        .position-card:hover {
            background: rgba(0, 255, 170, 0.05);
            transform: translateX(5px);
        }

        .position-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .symbol {
            font-weight: 700;
            font-size: 1.1rem;
            color: var(--accent);
        }

        .profit-loss {
            font-weight: 600;
        }

        .profit { color: var(--positive); }
        .loss { color: var(--negative); }

        /* PnL Notification Styles */
        .pnl-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .pnl-notification.profit {
            background: rgba(0, 255, 170, 0.2);
            border: 1px solid var(--positive);
            color: var(--positive);
        }

        .pnl-notification.loss {
            background: rgba(255, 85, 85, 0.2);
            border: 1px solid var(--negative);
            color: var(--negative);
        }

        /* Activity Log */
        .activity-container {
            grid-column: span 2;
            height: 350px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .activity-log {
            flex: 1 1 0;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding-right: 5px;
        }

        @media (max-width: 768px) {
            .activity-container {
                grid-column: span 1;
                height: 200px;
            }
        }

        .activity-log::-webkit-scrollbar {
            width: 6px;
        }

        .activity-log::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        .activity-log::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 3px;
        }

        .activity-log::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 170, 0.8);
        }

        .activity-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            border-left: 3px solid;
            min-height: 40px;
            flex-shrink: 0;
        }

        .activity-item.buy { border-left-color: var(--positive); }
        .activity-item.sell { border-left-color: var(--negative); }
        .activity-item.system { border-left-color: var(--warning); }

        .activity-time {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-left: auto;
        }

        /* Telegram Panel */
        .telegram-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid var(--border);
        }

        .telegram-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.3s;
        }
        
        .telegram-status:hover {
            background: rgba(0, 0, 0, 0.4);
        }
        
        .panel-content {
            overflow: hidden;
            transition: max-height 0.4s ease-in-out, opacity 0.3s ease-in-out, padding 0.3s ease-in-out;
            max-height: 1000px;
            opacity: 1;
            padding-top: 0;
        }
        
        .panel-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: 0;
            margin-bottom: 0;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .input-group input {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .input-group input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 10px rgba(0, 255, 170, 0.2);
        }

        /* Performance Metrics */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .metric-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--border);
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .app-header {
                flex-direction: column;
                gap: 15px;
                padding: 15px;
            }
            
            .logo-section {
                justify-content: center;
            }
            
            .status-panel {
                flex-direction: column;
                gap: 10px;
                width: 100%;
            }
            
            .connection-status {
                justify-content: center;
                width: 100%;
                font-size: 0.85rem;
                padding: 6px 12px;
            }
            
            .connection-status div {
                align-items: center !important;
                text-align: center;
            }
            
            /* Mobile Activity Indicator Adjustments */
            .activity-indicator {
                top: 10px;
                right: 10px;
                transform: scale(0.8);
            }
            
            .indicator-pulse {
                width: 25px;
                height: 25px;
            }
            
            .indicator-icon {
                width: 25px;
                height: 25px;
                font-size: 1rem;
            }
            
            /* Status Bar Mobile Optimization */
            .status-bar {
                height: 3px;
            }
            
            .control-buttons {
                flex-direction: column;
                gap: 10px;
            }
            
            .activity-container {
                grid-column: span 1;
                height: auto;
                min-height: 300px;
                display: flex;
                flex-direction: column;
            }
            
            .chart-container {
                height: 350px;
                min-height: 250px;
            }
            
            .activity-container {
                height: auto;
                min-height: 300px;
                display: flex;
                flex-direction: column;
            }
            
            .positions-container {
                height: 250px;
                min-height: 200px;
            }
            
            .chart-wrapper {
                height: calc(100% - 80px);
                min-height: 200px;
            }

            .chart-controls {
                margin-bottom: 10px;
                padding: 5px 0;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
            
            .telegram-panel {
                padding: 10px;
            }
            
            .input-group input {
                padding: 8px;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
            }

            /* Mobile-First Quick Actions */
            .mobile-quick-actions {
                display: flex;
                gap: 10px;
                margin-bottom: 15px;
            }
            
            .mobile-quick-actions .btn {
                flex: 1;
                padding: 12px 8px;
                font-size: 0.8rem;
            }
        }

        /* Tablet Responsive */
        @media (min-width: 769px) and (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr 1fr;
                gap: 20px;
            }
            
            .chart-container {
                grid-column: span 2;
                height: 350px;
            }
            
            .activity-container {
                grid-column: span 2;
            }
            
            .app-header {
                padding: 15px 20px;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        /* Desktop Enhancements */
        @media (min-width: 1025px) {
            .app-container {
                padding: 25px;
            }
            
            .main-grid {
                gap: 30px;
            }
            
            .glassmorphism-card {
                padding: 25px;
            }
        }

        /* Device-Specific Optimizations */
        .mobile-only {
            display: none;
        }
        
        @media (max-width: 768px) {
            .mobile-only {
                display: block;
            }
            
            .desktop-only {
                display: none;
            }
        }

        /* Enhanced Price Tickers for Mobile */
        .price-tickers {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding: 10px 0;
            margin-bottom: 15px;
        }
        
        .price-ticker {
            min-width: 120px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            border-left: 3px solid var(--accent);
            text-align: center;
        }
        
        .ticker-symbol {
            font-weight: 700;
            color: var(--accent);
            font-size: 0.9rem;
        }
        
        .ticker-price {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 5px 0;
        }
        
        .ticker-change {
            font-size: 0.8rem;
        }

        /* Advanced Chart Controls */
        .chart-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            margin-top: 10px;
            flex-wrap: nowrap;
            padding: 10px 0;
            border-bottom: 1px solid var(--border);
            position: relative;
            z-index: 10;
            background: transparent;
            overflow: visible;
            min-height: 50px;
        }
        
        .chart-btn {
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            position: relative;
            z-index: 11;
            min-height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        
        .chart-btn:hover,
        .chart-btn.active {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
            z-index: 12;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 255, 170, 0.3);
        }

        /* Ensure chart controls are always accessible */
        .chart-controls > div {
            z-index: 11;
            position: relative;
        }

        /* Enhanced Position Cards */
        .position-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--accent);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .position-card:hover {
            background: rgba(0, 255, 170, 0.05);
            transform: translateX(5px);
            box-shadow: 0 4px 15px rgba(0, 255, 170, 0.1);
        }

        /* Touch-Friendly Controls */
        @media (hover: none) and (pointer: coarse) {
            .btn {
                min-height: 44px;
                font-size: 1rem;
            }
            
            .slider {
                height: 12px;
            }
            
            .slider::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
            }
            
            .input-group input {
                min-height: 44px;
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00cc88;
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 255, 170, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Notification Styles */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
            max-width: 300px;
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- Animated Status Bar -->
    <div id="globalStatusBar" class="status-bar"></div>
    
    <div class="app-container">
        <!-- Header -->
        <header class="app-header">
            <div class="logo-section">
                <img src="logo.jpg" alt="IQTS Logo" class="logo">
                <h1 class="app-title">IQTS Bot</h1>
            </div>
            <div class="status-panel">
                <div class="connection-status">
                    <span class="status-dot" id="statusDot"></span>
                    <span id="connectionText">Connecting...</span>
                </div>
                <div class="connection-status" id="marketStatusIndicator">
                    <span class="status-dot" style="background: var(--warning); box-shadow: 0 0 10px var(--warning);"></span>
                    <span>Market Status: Loading...</span>
                </div>
                <div class="connection-status" id="marketCountdown" style="min-width: 200px;">
                    <i class="fas fa-clock"></i>
                    <span>Countdown: Loading...</span>
                </div>
                <div class="connection-status" id="currentTime" style="min-width: 120px;">
                    <i class="fas fa-clock"></i>
                    <span>Time: Loading...</span>
                </div>
                <div class="connection-status">
                    <i class="fab fa-telegram-plane"></i>
                    <span id="telegramStatus">Telegram: Offline</span>
                </div>
            </div>
        </header>

        <!-- Main Grid -->
        <div class="main-grid">
            <!-- Mobile Price Tickers -->
            <div class="mobile-only" style="grid-column: span 2;">
                <div class="glassmorphism-card" style="padding: 15px;">
                    <div class="price-tickers" id="priceTickers"></div>
                </div>
            </div>

            <!-- Chart Container -->
            <div class="glassmorphism-card chart-container">
                <!-- Trading Activity Indicator -->
                <div id="activityIndicator" class="activity-indicator">
                    <div class="indicator-pulse"></div>
                    <div class="indicator-icon">
                        <i class="fas fa-chart-line"></i>
                    </div>
                </div>
                
                <div class="card-header">
                    <h2 class="card-title">
                        <i class="fas fa-chart-line"></i>
                        Live Market Data
                    </h2>
                    <div>
                        <select id="symbolSelect" style="background: rgba(0,0,0,0.5); color: var(--text-primary); border: 1px solid var(--border); border-radius: 6px; padding: 8px;">
                            <option value="AAPL">AAPL</option>
                            <option value="TSLA">TSLA</option>
                            <option value="NVDA">NVDA</option>
                            <option value="MSFT">MSFT</option>
                            <option value="GOOGL">GOOGL</option>
                        </select>
                    </div>
                </div>
                
                <!-- Chart Controls -->
                <div class="chart-controls desktop-only" style="position: relative; z-index: 15;">
                    <button class="chart-btn active" data-timeframe="1m">1m</button>
                    <button class="chart-btn" data-timeframe="5m">5m</button>
                    <button class="chart-btn" data-timeframe="15m">15m</button>
                    <button class="chart-btn" data-timeframe="1D">1D</button>
                    <button class="chart-btn" data-timeframe="1W">1W</button>
                    <button class="chart-btn" data-timeframe="1M">1M</button>
                    <button class="chart-btn" data-timeframe="3M">3M</button>
                    <div style="margin-left: auto; display: flex; gap: 10px; position: relative; z-index: 15; min-width: fit-content; flex-shrink: 0;">
                        <button class="chart-btn active" data-chart="line" style="background: var(--accent); color: #000;">Line</button>
                        <button class="chart-btn" data-chart="candlestick">Candlestick</button>
                        <button class="chart-btn" data-chart="heikin-ashi">Heikin-Ashi</button>
                        <button class="chart-btn" data-chart="renko">Renko</button>
                        <button class="chart-btn" data-chart="tick">Tick</button>
                    </div>
                </div>
                
                <div class="chart-wrapper">
                    <canvas id="tradingChart"></canvas>
                </div>
            </div>

            <!-- Control Panel -->
            <div class="glassmorphism-card">
                <div class="card-header">
                    <h2 class="card-title">
                        <i class="fas fa-robot"></i>
                        AI Controls
                    </h2>
                </div>
                <div class="control-panel">
                    <!-- Mobile Quick Actions -->
                    <div class="mobile-quick-actions mobile-only">
                        <button id="quickBuy" class="btn btn-start">
                            <i class="fas fa-arrow-up"></i>
                            Quick Buy
                        </button>
                        <button id="quickSell" class="btn btn-stop">
                            <i class="fas fa-arrow-down"></i>
                            Quick Sell
                        </button>
                    </div>

                    <div class="control-buttons">
                        <button id="startBtn" class="btn btn-start">
                            <i class="fas fa-play"></i>
                            <span class="desktop-only">Start Trading</span>
                            <span class="mobile-only">Start</span>
                        </button>
                        <button id="stopBtn" class="btn btn-stop">
                            <i class="fas fa-stop"></i>
                            <span class="desktop-only">Stop Trading</span>
                            <span class="mobile-only">Stop</span>
                        </button>
                    </div>
                    
                    <button id="emergencyBtn" class="btn btn-emergency">
                        <i class="fas fa-exclamation-triangle"></i>
                    </button>

                    <div class="risk-control">
                        <label for="riskSlider">Risk Level: <span id="riskValue">5</span></label>
                        <div class="risk-slider">
                            <input type="range" min="1" max="10" value="5" class="slider" id="riskSlider">
                        </div>
                    </div>

                    <!-- Audio Controls -->
                    <div class="telegram-panel" style="margin-bottom: 20px;">
                        <div class="telegram-status" style="cursor: pointer;" onclick="togglePanel('audioPanel')">
                            <i class="fas fa-volume-up"></i>
                            <span>Audio Settings</span>
                            <i class="fas fa-chevron-down" id="audioPanelIcon" style="margin-left: auto; transition: transform 0.3s;"></i>
                        </div>
                        <div id="audioPanel" class="panel-content">
                            <div class="input-group">
                                <label style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" id="audioEnabled" checked style="width: auto;">
                                    Enable Audio Notifications
                                </label>
                            </div>
                            <div class="input-group">
                                <label for="audioVolume">Volume: <span id="volumeValue">50%</span></label>
                                <input type="range" min="0" max="100" value="50" class="slider" id="audioVolume">
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button id="testTradeSound" class="btn" style="background: rgba(0,255,170,0.2); color: var(--accent); flex: 1; padding: 8px;">
                                    <i class="fas fa-play"></i>
                                    Test Trade
                                </button>
                                <button id="testAlertSound" class="btn" style="background: rgba(255,170,0,0.2); color: var(--warning); flex: 1; padding: 8px;">
                                    <i class="fas fa-bell"></i>
                                    Test Alert
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Alpaca API Configuration -->
                    <div class="telegram-panel" style="margin-bottom: 20px;">
                        <div class="telegram-status" style="cursor: pointer;" onclick="togglePanel('alpacaPanel')">
                            <i class="fas fa-chart-line"></i>
                            <span>Alpaca API</span>
                            <i class="fas fa-chevron-down" id="alpacaPanelIcon" style="margin-left: auto; transition: transform 0.3s;"></i>
                        </div>
                        <div id="alpacaPanel" class="panel-content">
                            <div class="input-group">
                                <label for="alpacaKeyId">API Key ID</label>
                                <input type="password" id="alpacaKeyId" placeholder="Enter your Alpaca Key ID">
                            </div>
                            <div class="input-group">
                                <label for="alpacaSecret">Secret Key</label>
                                <input type="password" id="alpacaSecret" placeholder="Enter your Alpaca Secret Key">
                            </div>
                            <div class="input-group">
                                <label style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" id="paperTrading" checked style="width: auto;">
                                    Paper Trading (Recommended)
                                </label>
                            </div>
                            <button id="connectAlpaca" class="btn" style="background: rgba(76,175,80,0.2); color: #4CAF50; width: 100%; margin-bottom: 10px; padding: 12px;">
                                <i class="fas fa-link"></i>
                                Connect Alpaca
                            </button>
                        </div>
                    </div>

                    <!-- Telegram Configuration -->
                    <div class="telegram-panel">
                        <div class="telegram-status" style="cursor: pointer;" onclick="togglePanel('telegramPanel')">
                            <i class="fab fa-telegram-plane"></i>
                            <span>Telegram Alerts</span>
                            <i class="fas fa-chevron-down" id="telegramPanelIcon" style="margin-left: auto; transition: transform 0.3s;"></i>
                        </div>
                        <div id="telegramPanel" class="panel-content">
                            <div class="input-group">
                                <label for="botToken">Bot Token</label>
                                <input type="password" id="botToken" placeholder="Enter your bot token">
                            </div>
                            <div class="input-group">
                                <label for="chatId">Chat ID</label>
                                <input type="text" id="chatId" placeholder="Enter your chat ID">
                            </div>
                            <div class="input-group">
                                <label style="display: flex; align-items: center; gap: 8px;">
                                    <i class="fab fa-telegram-plane" style="color: #0088cc;"></i>
                                    <span id="telegramConnectedLabel">Telegram: Not Connected</span>
                                </label>
                            </div>
                            <button id="connectTelegram" class="btn" style="background: rgba(0,136,204,0.2); color: #0088cc; width: 100%; padding: 12px;">
                                <i class="fab fa-telegram-plane"></i>
                                Connect Telegram
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Positions -->
            <div class="glassmorphism-card positions-container">
                <div class="card-header">
                    <h2 class="card-title">
                        <i class="fas fa-boxes"></i>
                        Active Positions
                    </h2>
                    <span class="badge" id="positionsCount">0</span>
                </div>
                <div class="positions-grid" id="positionsGrid">
                    <div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                        No active positions
                    </div>
                </div>
            </div>

            <!-- Performance Metrics -->
            <div class="glassmorphism-card">
                <div class="card-header">
                    <h2 class="card-title">
                        <i class="fas fa-tachometer-alt"></i>
                        Performance
                    </h2>
                </div>
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="totalPnL" style="color: var(--positive);">+$0.00</div>
                        <div class="metric-label">Total P&L</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="dailyPnL">+$0.00</div>
                        <div class="metric-label">Daily P&L</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="winRate">0%</div>
                        <div class="metric-label">Win Rate</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="totalTrades">0</div>
                        <div class="metric-label">Total Trades</div>
                    </div>
                </div>
            </div>

            <!-- System Health Dashboard -->
            <div class="glassmorphism-card">
                <div class="card-header">
                    <h2 class="card-title">
                        <i class="fas fa-heartbeat"></i>
                        System Health
                    </h2>
                </div>
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="cpuUsage">0%</div>
                        <div class="metric-label">CPU Usage</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="memoryUsage">0 MB</div>
                        <div class="metric-label">Memory</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="uptimeCounter">0:00:00</div>
                        <div class="metric-label">Uptime</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="apiLatency">0 ms</div>
                        <div class="metric-label">API Latency</div>
                    </div>
                </div>
                <div id="performanceSuggestions" style="padding: 10px; font-size: 0.8rem; color: var(--text-secondary); background: rgba(0,0,0,0.2); border-radius: 8px; border-left: 3px solid var(--accent); margin-top: 15px;">
                    System monitoring initialized...
                </div>
            </div>

            <!-- Activity Log -->
            <div class="glassmorphism-card activity-container">
                <div class="card-header">
                    <h2 class="card-title">
                        <i class="fas fa-bell"></i>
                        Activity Log
                    </h2>
                    <button id="clearLog" class="btn" style="background: rgba(255,85,85,0.2); color: var(--negative); padding: 8px 16px;">
                        <i class="fas fa-trash"></i>
                        Clear
                    </button>
                </div>
                <div class="activity-log" id="activityLog"></div>
            </div>
        </div>

        <!-- Setup Guide -->
        <div class="glassmorphism-card" id="setupGuide" style="margin-top: 25px;">
            <div class="card-header">
                <h2 class="card-title">
                    <i class="fas fa-book"></i>
                    Setup Guide
                </h2>
                <button id="toggleGuide" class="btn" style="background: rgba(0,255,170,0.2); color: var(--accent); padding: 8px 16px;">
                    <i class="fas fa-eye"></i>
                    Toggle
                </button>
            </div>
            <div id="guideContent" style="display: none;">
                <div style="padding: 20px; background: rgba(0,0,0,0.2); border-radius: 8px; margin-bottom: 15px;">
                    <h3 style="color: var(--accent); margin-bottom: 10px;">ðŸ”— Alpaca API Setup</h3>
                    <ol style="line-height: 1.6; color: var(--text-secondary);">
                        <li>Go to <a href="https://alpaca.markets" target="_blank" style="color: var(--accent);">alpaca.markets</a> and create an account</li>
                        <li>Navigate to "Your API Keys" in your dashboard</li>
                        <li>Generate Paper Trading API keys (recommended for testing)</li>
                        <li>Copy your "Key ID" and "Secret Key"</li>
                        <li>Paste them in the Alpaca API section above</li>
                        <li>Click "Connect Alpaca" to test the connection</li>
                    </ol>
                </div>

                <div style="padding: 20px; background: rgba(0,0,0,0.2); border-radius: 8px; margin-bottom: 15px;">
                    <h3 style="color: var(--accent); margin-bottom: 10px;">ðŸ“± Telegram Bot Setup</h3>
                    <ol style="line-height: 1.6; color: var(--text-secondary);">
                        <li>Open Telegram and search for "@BotFather"</li>
                        <li>Send "/newbot" and follow the instructions</li>
                        <li>Copy the bot token (looks like: 123456789:ABCdefGHI...)</li>
                        <li>Start a chat with your bot and send any message</li>
                        <li>Go to: https://api.telegram.org/bot<strong>YOUR_BOT_TOKEN</strong>/getUpdates</li>
                        <li>Find your chat ID in the response</li>
                        <li>Enter both values in the Telegram section above</li>
                    </ol>
                </div>

                <div style="padding: 20px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <h3 style="color: var(--accent); margin-bottom: 10px;">âš¡ Quick Start</h3>
                    <ul style="line-height: 1.6; color: var(--text-secondary);">
                        <li><strong>Paper Trading:</strong> Always use paper trading for testing</li>
                        <li><strong>Risk Level:</strong> Start with low risk (1-3) while learning</li>
                        <li><strong>Emergency Stop:</strong> Press ESC key or red button to stop immediately</li>
                        <li><strong>Keyboard Shortcuts:</strong> Ctrl+S to start/stop trading</li>
                        <li><strong>Audio:</strong> Browser may ask for audio permission</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Personal Notes Section -->
        <div class="glassmorphism-card" id="personalNotesCard" style="margin-top: 25px;">
            <div class="card-header">
                <h2 class="card-title">
                    <i class="fas fa-sticky-note"></i>
                    Personal Notes
                </h2>
            </div>
            <div style="padding: 20px;">
                <label for="personalNotes" style="color: var(--text-secondary); font-size: 0.95rem;">Store your API keys, Telegram ID, or any private info here. <b>Only you</b> can see these notes (saved in your browser).</label>
                <textarea id="personalNotes" rows="5" style="width:100%; margin-top:10px; background:rgba(0,0,0,0.2); color:var(--text-primary); border-radius:8px; border:1px solid var(--border); padding:12px; font-size:1rem;"></textarea>
                <button id="saveNotesBtn" class="btn" style="margin-top:12px; background:var(--accent); color:#000;">Save Notes</button>
                <span id="notesSavedMsg" style="margin-left:15px; color:var(--positive); display:none;">Saved!</span>
            </div>
        </div>

        <script>
        // Personal Notes save/load logic
        document.addEventListener('DOMContentLoaded', function() {
            const notesArea = document.getElementById('personalNotes');
            const saveBtn = document.getElementById('saveNotesBtn');
            const savedMsg = document.getElementById('notesSavedMsg');
            // Load notes from localStorage
            if (localStorage.getItem('personalNotes')) {
                notesArea.value = localStorage.getItem('personalNotes');
            }
            // Save notes to localStorage
            saveBtn.addEventListener('click', function() {
                localStorage.setItem('personalNotes', notesArea.value);
                savedMsg.style.display = 'inline';
                setTimeout(() => { savedMsg.style.display = 'none'; }, 1500);
            });
        });
        </script>
    </div>

    <!-- Audio Elements -->
    <audio id="tradeExecutedSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvGIdBj2c4PDAeSMFl" type="audio/wav">
    </audio>
    <audio id="alertSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvGIdBj2c4PDAeSMFl" type="audio/wav">
    </audio>
    <audio id="successSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRgAJAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAIAABBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvGIdBj2c4PDAeSMFl" type="audio/wav">
    </audio>
    <audio id="errorSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRgAEAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAEAABBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvGIdBj2c4PDAeSMFl" type="audio/wav">
    </audio>
    <audio id="startSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRgAGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAGAABBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvGIdBj2c4PDAeSMFl" type="audio/wav">
    </audio>
    <audio id="stopSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRgADAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQADAABBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvGIdBj2c4PDAeSMFl" type="audio/wav">
    </audio>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/notyf/3.10.0/notyf.min.js"></script>

    <script>
        // Global emergency test function - must be first
        // Emergency test function removed - using simplified Chart.js implementation

        // Enhanced library loading test
        window.addEventListener('load', () => {
            // Ensure logo is always visible
            const logo = document.querySelector('.logo');
            if (logo) {
                logo.style.display = 'block';
                logo.style.visibility = 'visible';
                logo.style.opacity = '1';
                
                // Add error handling for logo
                logo.onerror = function() {
                    this.style.background = 'linear-gradient(45deg, var(--accent), #1a1a2e)';
                    this.style.border = '2px solid var(--accent)';
                    this.style.display = 'block';
                    this.style.visibility = 'visible';
                    this.style.opacity = '1';
                };
                
                // Add load success handling
                logo.onload = function() {
                    this.style.display = 'block';
                    this.style.visibility = 'visible';
                    this.style.opacity = '1';
                };
            }
            
            setTimeout(() => {
                console.log('=== ENHANCED LIBRARY LOAD TEST ===');
                console.log('Page load time:', Date.now());
                console.log('Library load time:', window.libraryLoadTime || 'Not loaded');
                console.log('Library load error:', window.libraryLoadError || false);
                console.log('LightweightCharts available:', typeof LightweightCharts !== 'undefined');
                console.log('Library load flag:', window.lightweightChartsLoaded);
                
                if (typeof LightweightCharts !== 'undefined') {
                    console.log('LightweightCharts version:', LightweightCharts.version || 'Unknown');
                    console.log('LightweightCharts methods:', Object.keys(LightweightCharts));
                    console.log('createChart available:', typeof LightweightCharts.createChart === 'function');
                    console.log('CrosshairMode available:', !!LightweightCharts.CrosshairMode);
                    
                    // Test chart creation capability
                    try {
                        const testDiv = document.createElement('div');
                        testDiv.style.width = '100px';
                        testDiv.style.height = '100px';
                        testDiv.style.position = 'absolute';
                        testDiv.style.left = '-1000px';
                        document.body.appendChild(testDiv);
                        
                        const testChart = LightweightCharts.createChart(testDiv, {
                            width: 100,
                            height: 100
                        });
                        
                        const testSeries = testChart.addCandlestickSeries();
                        console.log('âœ… Library test successful - chart creation works');
                        
                        testChart.remove();
                        document.body.removeChild(testDiv);
                    } catch (testError) {
                        console.error('âŒ Library test failed:', testError);
                    }
                } else {
                    console.error('âŒ LightweightCharts library not available after page load');
                    
                    // Remove Lightweight Charts dependency - use Chart.js only
                    console.log('Using Chart.js only for charting');
                    window.lightweightChartsLoaded = false;
                }
                console.log('=== END LIBRARY TEST ===');
            }, 2000);
        });
        // Alpaca API Integration Class
        class AlpacaAPI {
            constructor(config) {
                this.apiKey = config.apiKey;
                this.secretKey = config.secretKey;
                this.baseUrl = config.paperTrading ? config.baseUrl : config.liveUrl;
                this.dataUrl = 'https://data.alpaca.markets';
            }

            // Create authorization headers
            getHeaders() {
                return {
                    'APCA-API-KEY-ID': this.apiKey,
                    'APCA-API-SECRET-KEY': this.secretKey,
                    'Content-Type': 'application/json'
                };
            }

            // Get account information
            async getAccount() {
                const response = await fetch(`${this.baseUrl}/v2/account`, {
                    headers: this.getHeaders()
                });
                
                if (!response.ok) {
                    throw new Error(`Alpaca API Error: ${response.status} ${response.statusText}`);
                }
                
                return await response.json();
            }

            // Get portfolio history
            async getPortfolio() {
                const response = await fetch(`${this.baseUrl}/v2/account/portfolio/history`, {
                    headers: this.getHeaders()
                });
                
                if (!response.ok) {
                    throw new Error(`Portfolio API Error: ${response.status}`);
                }
                
                return await response.json();
            }

            // Get positions
            async getPositions() {
                const response = await fetch(`${this.baseUrl}/v2/positions`, {
                    headers: this.getHeaders()
                });
                
                if (!response.ok) {
                    throw new Error(`Positions API Error: ${response.status}`);
                }
                
                return await response.json();
            }

            // Create an order
            async createOrder(orderData) {
                const response = await fetch(`${this.baseUrl}/v2/orders`, {
                    method: 'POST',
                    headers: this.getHeaders(),
                    body: JSON.stringify(orderData)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(`Order Error: ${error.message || response.statusText}`);
                }
                
                return await response.json();
            }

            // Get latest quotes for symbols
            async getLatestQuotes(symbols) {
                const symbolsParam = symbols.join(',');
                const response = await fetch(`${this.dataUrl}/v2/stocks/quotes/latest?symbols=${symbolsParam}`, {
                    headers: this.getHeaders()
                });
                
                if (!response.ok) {
                    throw new Error(`Quotes API Error: ${response.status}`);
                }
                
                const data = await response.json();
                return data.quotes;
            }

            // Get latest bars (OHLCV data)
            async getLatestBars(symbols) {
                const symbolsParam = symbols.join(',');
                const response = await fetch(`${this.dataUrl}/v2/stocks/bars/latest?symbols=${symbolsParam}`, {
                    headers: this.getHeaders()
                });
                
                if (!response.ok) {
                    throw new Error(`Bars API Error: ${response.status}`);
                }
                
                const data = await response.json();
                return data.bars;
            }

            // Get orders
            async getOrders(status = 'all') {
                const response = await fetch(`${this.baseUrl}/v2/orders?status=${status}`, {
                    headers: this.getHeaders()
                });
                
                if (!response.ok) {
                    throw new Error(`Orders API Error: ${response.status}`);
                }
                
                return await response.json();
            }

            // Cancel all orders
            async cancelAllOrders() {
                const response = await fetch(`${this.baseUrl}/v2/orders`, {
                    method: 'DELETE',
                    headers: this.getHeaders()
                });
                
                if (!response.ok) {
                    throw new Error(`Cancel Orders Error: ${response.status}`);
                }
                
                return await response.json();
            }

            // Close all positions
            async closeAllPositions() {
                const response = await fetch(`${this.baseUrl}/v2/positions`, {
                    method: 'DELETE',
                    headers: this.getHeaders()
                });
                
                if (!response.ok) {
                    throw new Error(`Close Positions Error: ${response.status}`);
                }
                
                return await response.json();
            }

            // Get market status
            async getMarketClock() {
                const response = await fetch(`${this.baseUrl}/v2/clock`, {
                    headers: this.getHeaders()
                });
                
                if (!response.ok) {
                    throw new Error(`Clock API Error: ${response.status}`);
                }
                
                return await response.json();
            }
        }

        // IQTS Bot - Complete Trading System
        class IQTSBot {
            constructor() {
                this.isRunning = false;
                this.positions = [];
                this.trades = [];
                this.totalPnL = 0;
                this.dailyPnL = 0;
                this.winRate = 0;
                this.riskLevel = 5;
                this.currentSymbol = 'AAPL';
                this.telegramConnected = false;
                this.alpacaConnected = false;
                this.emergencyStopActive = false;
                this.lastTradeWasLoss = false;
                
                // Configuration
                this.config = {
                    alpaca: {
                        apiKey: '',
                        secretKey: '',
                        paperTrading: true,
                        baseUrl: 'https://paper-api.alpaca.markets',
                        liveUrl: 'https://api.alpaca.markets'
                    },
                    telegram: {
                        botToken: '',
                        chatId: ''
                    },
                    audio: {
                        enabled: true,
                        volume: 0.5
                    }
                };

                // Alpaca API instance
                this.alpacaAPI = null;

                // Market data simulation
                this.marketData = {
                    AAPL: { price: 175.50, change: 2.30 },
                    TSLA: { price: 248.75, change: -5.20 },
                    NVDA: { price: 425.10, change: 8.45 },
                    MSFT: { price: 335.25, change: 1.85 },
                    GOOGL: { price: 125.80, change: -2.10 }
                };

                this.initializeUI();
                this.initializeChart();
                this.initializeAudio();
                this.initializePriceTickers();
                this.createStatusBar();
                this.startDataStream();
                
                // Initialize Market Hours Features
                this.updateMarketSessionIndicator();
                this.startMarketCountdownTimer();
                this.updateCurrentTime(); // Start the clock immediately
                this.checkMarketHours();
                this.startSystemMonitoring();
                this.setupScheduledReports();
                this.setupPnLAlerts();
                this.setupTelegramCommands();
                
                // Update market status every minute
                setInterval(() => this.updateMarketSessionIndicator(), 60000);
                
                // Add resize handler for chart
                window.addEventListener('resize', () => {
                    if (this.chart) {
                        this.chart.resize();
                    }
                });
                
                // Add initial activity
                this.addActivity('IQTS Bot initialized successfully', 'system');
                this.addActivity('Ready for trading operations', 'system');
                this.addActivity('Chart system loaded', 'system');
                this.addActivity('Audio system ready', 'system');
                this.addActivity('Market data stream starting', 'system');
                this.addActivity('Market hours monitoring active', 'system');
                this.addActivity('System health monitoring started', 'system');
                this.addActivity('Enhanced Telegram integration ready', 'system');
                this.addActivity('Scheduled reports initialized', 'system');
                this.addActivity('All systems operational', 'system');
            }

            initializeUI() {
                // Control buttons
                document.getElementById('startBtn').addEventListener('click', () => this.startTrading());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopTrading());
                document.getElementById('emergencyBtn').addEventListener('click', () => this.emergencyStop());
                
                // Risk slider
                const riskSlider = document.getElementById('riskSlider');
                riskSlider.addEventListener('input', (e) => {
                    this.riskLevel = e.target.value;
                    document.getElementById('riskValue').textContent = e.target.value;
                });

                // Audio controls
                const audioEnabled = document.getElementById('audioEnabled');
                audioEnabled.addEventListener('change', (e) => {
                    this.config.audio.enabled = e.target.checked;
                    this.addActivity(`Audio notifications ${e.target.checked ? 'enabled' : 'disabled'}`, 'system');
                });

                const audioVolume = document.getElementById('audioVolume');
                audioVolume.addEventListener('input', (e) => {
                    this.config.audio.volume = e.target.value / 100;
                    document.getElementById('volumeValue').textContent = e.target.value + '%';
                });

                // Audio test buttons
                document.getElementById('testTradeSound').addEventListener('click', () => {
                    this.playAudio('trade');
                    this.addActivity('Trade sound test played', 'system');
                });

                document.getElementById('testAlertSound').addEventListener('click', () => {
                    this.playAudio('alert');
                    this.addActivity('Alert sound test played', 'system');
                });

                // Symbol selector
                document.getElementById('symbolSelect').addEventListener('change', (e) => {
                    this.currentSymbol = e.target.value;
                    this.updateChart();
                });

                // Telegram connection
                document.getElementById('connectTelegram').addEventListener('click', () => this.connectTelegram());
                
                // Alpaca connection
                document.getElementById('connectAlpaca').addEventListener('click', () => this.connectAlpaca());
                
                // Quick trading buttons (mobile)
                document.getElementById('quickBuy').addEventListener('click', () => this.quickTrade('BUY'));
                document.getElementById('quickSell').addEventListener('click', () => this.quickTrade('SELL'));
                
                // Chart controls
                document.querySelectorAll('.chart-btn[data-timeframe]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.chart-btn[data-timeframe]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.updateChartTimeframe(e.target.dataset.timeframe);
                    });
                });
                
                document.querySelectorAll('.chart-btn[data-chart]').forEach(btn => {
                    console.log('Attaching event listener to chart button:', btn.dataset.chart);
                    btn.addEventListener('click', (e) => {
                        console.log('Chart button clicked:', e.target.dataset.chart);
                        document.querySelectorAll('.chart-btn[data-chart]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.switchChartType(e.target.dataset.chart);
                    });
                });

                
                // Clear log
                document.getElementById('clearLog').addEventListener('click', () => this.clearActivityLog());

                // Setup guide toggle
                document.getElementById('toggleGuide').addEventListener('click', () => {
                    const content = document.getElementById('guideContent');
                    const button = document.getElementById('toggleGuide');
                    if (content.style.display === 'none') {
                        content.style.display = 'block';
                        button.innerHTML = '<i class="fas fa-eye-slash"></i> Hide';
                    } else {
                        content.style.display = 'none';
                        button.innerHTML = '<i class="fas fa-eye"></i> Show';
                    }
                });

                // Set initial UI state
                this.updateConnectionStatus();
                this.updateMetrics();
            }

            initializeChart() {
                const chartCanvas = document.getElementById('tradingChart');
                
                // Remove Lightweight Charts container visibility toggling
                chartCanvas.style.display = 'block';
                
                // Clear existing chart if it exists
                if (this.chart) {
                    this.chart.destroy();
                }

                // Create new Chart.js instance
                const ctx = chartCanvas.getContext('2d');
                this.chart = new Chart(ctx, {
                    type: 'line', // Default to line chart
                    data: {
                        labels: Array(50).fill().map((_, i) => i),
                        datasets: [{
                            label: 'Price',
                            data: this.generatePriceData(),
                            borderColor: '#00ffaa',
                            backgroundColor: this.createGradient(ctx, chartCanvas),
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0
                        }]
                    },
                    options: this.getChartOptions()
                });
            }

            // Helper method for gradient
            createGradient(ctx, chartCanvas) {
                const gradient = ctx.createLinearGradient(0, 0, 0, chartCanvas.height);
                gradient.addColorStop(0, 'rgba(0, 255, 170, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 255, 170, 0.05)');
                return gradient;
            }

            // Chart options
            getChartOptions() {
                return {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(20, 20, 40, 0.9)',
                            titleColor: '#00ffaa',
                            bodyColor: '#e0e0e0',
                            borderColor: '#00ffaa',
                            borderWidth: 1
                        }
                    },
                    scales: {
                        x: { display: false },
                        y: {
                            beginAtZero: false,
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: {
                                color: '#a0a0a0',
                                callback: function(value) { return '$' + value.toFixed(2); }
                            }
                        }
                    }
                };
            }

            createFallbackChart() {
                console.log('Creating fallback chart...');
                const ctx = document.getElementById('tradingChart').getContext('2d');
                
                this.chart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['1', '2', '3', '4', '5'],
                        datasets: [{
                            data: [100, 110, 95, 105, 120],
                            backgroundColor: ['#00ff00', '#00ff00', '#ff0000', '#00ff00', '#00ff00'],
                            borderWidth: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            x: { ticks: { color: '#e0e0e0' } },
                            y: { ticks: { color: '#e0e0e0' } }
                        }
                    }
                });
                
                this.addActivity('ðŸ”§ Fallback chart created', 'system');
            }

            initializeLightweightChart() {
                // Chart.js only implementation - no Lightweight Charts needed
                console.log('Using Chart.js for all charting functionality');
            }

            initializePriceTickers() {
                this.updatePriceTickers();
                // Update tickers every 3 seconds
                setInterval(() => this.updatePriceTickers(), 3000);
            }

            updatePriceTickers() {
                const container = document.getElementById('priceTickers');
                if (!container) return;

                container.innerHTML = Object.entries(this.marketData).map(([symbol, data]) => {
                    const changeClass = data.change >= 0 ? 'profit' : 'loss';
                    const changeIcon = data.change >= 0 ? 'â†—' : 'â†˜';
                    
                    return `
                        <div class="price-ticker" onclick="window.iqtsBot.selectSymbol('${symbol}')">
                            <div class="ticker-symbol">${symbol}</div>
                            <div class="ticker-price">$${data.price.toFixed(2)}</div>
                            <div class="ticker-change ${changeClass}">
                                ${changeIcon} ${data.change >= 0 ? '+' : ''}${data.change.toFixed(2)}
                            </div>
                        </div>
                    `;
                }).join('');
            }

            selectSymbol(symbol) {
                this.currentSymbol = symbol;
                document.getElementById('symbolSelect').value = symbol;
                this.updateChart();
            }

            quickTrade(action) {
                if (!this.isRunning) {
                    this.showNotification('Please start trading first', 'warning');
                    return;
                }

                const quantity = 1; // Quick trade with 1 share
                const price = this.marketData[this.currentSymbol].price;

                if (action === 'BUY') {
                    if (this.alpacaConnected) {
                        this.executeRealBuy(this.currentSymbol, quantity);
                    } else {
                        this.executeBuy(this.currentSymbol, quantity, price);
                    }
                } else if (action === 'SELL' && this.positions.length > 0) {
                    if (this.alpacaConnected) {
                        this.executeRealSell(this.currentSymbol, quantity);
                    } else {
                        this.executeSell(this.currentSymbol, quantity, price);
                    }
                } else {
                    this.showNotification('No positions to sell', 'warning');
                }
            }

            updateChartTimeframe(timeframe) {
                // Update chart data based on timeframe
                this.addActivity(`Chart timeframe changed to ${timeframe}`, 'system');
                this.updateChart();
            }

            switchChartType(chartType) {
                if (!this.chart) return;

                if (chartType === 'candlestick') {
                    // Switch to candlestick using Chart.js
                    this.chart.config.type = 'bar';
                    this.chart.config.data.datasets[0] = this.getCandlestickData();
                    this.chart.update();
                } else if (chartType === 'heikin-ashi') {
                    // Switch to Heikin-Ashi chart
                    this.chart.config.type = 'bar';
                    this.chart.config.data.datasets[0] = this.getHeikinAshiData();
                    this.chart.update();
                } else if (chartType === 'renko') {
                    // Switch to Renko chart
                    this.chart.config.type = 'bar';
                    this.chart.config.data.datasets[0] = this.getRenkoData();
                    this.chart.update();
                } else if (chartType === 'tick') {
                    // Switch to Tick chart
                    this.chart.config.type = 'line';
                    this.chart.config.data.datasets[0] = this.getTickData();
                    this.chart.update();
                } else {
                    // Switch back to line chart
                    this.chart.config.type = 'line';
                    this.chart.config.data.datasets[0] = {
                        label: 'Price',
                        data: this.generatePriceData(),
                        borderColor: '#00ffaa',
                        backgroundColor: this.createGradient(this.chart.ctx, this.chart.canvas),
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0
                    };
                    this.chart.update();
                }
            }

            getCandlestickData() {
                const basePrice = this.marketData[this.currentSymbol].price;
                const data = [];
                let currentPrice = basePrice;
                
                for (let i = 0; i < 20; i++) {
                    const change = (Math.random() - 0.5) * 2;
                    currentPrice += change;
                    data.push(currentPrice);
                }
                
                return {
                    label: 'Price',
                    data: data,
                    backgroundColor: data.map((val, i, arr) => 
                        i > 0 && val > arr[i-1] ? '#00ff88' : '#ff4444'),
                    borderColor: data.map((val, i, arr) => 
                        i > 0 && val > arr[i-1] ? '#00ff88' : '#ff4444'),
                    borderWidth: 1,
                    barThickness: 10
                };
            }

            getHeikinAshiData() {
                const basePrice = this.marketData[this.currentSymbol].price;
                const data = [];
                let haClose = basePrice;
                let haOpen = basePrice;
                
                for (let i = 0; i < 20; i++) {
                    const change = (Math.random() - 0.5) * 3;
                    const newClose = haClose + change;
                    
                    // Heikin-Ashi formula
                    const haCloseNew = (basePrice + haClose + Math.max(basePrice, newClose) + Math.min(basePrice, newClose)) / 4;
                    const haOpenNew = (haOpen + haClose) / 2;
                    
                    data.push(haCloseNew);
                    haClose = haCloseNew;
                    haOpen = haOpenNew;
                }
                
                return {
                    label: 'Heikin-Ashi',
                    data: data,
                    backgroundColor: data.map((val, i, arr) => 
                        i > 0 && val > arr[i-1] ? '#00ff88' : '#ff4444'),
                    borderColor: data.map((val, i, arr) => 
                        i > 0 && val > arr[i-1] ? '#00ff88' : '#ff4444'),
                    borderWidth: 1,
                    barThickness: 8
                };
            }

            getRenkoData() {
                const basePrice = this.marketData[this.currentSymbol].price;
                const data = [];
                let currentPrice = basePrice;
                const brickSize = 2; // Price movement threshold
                let bricks = 0;
                let attempts = 0;
                // Ensure at least 10 bricks
                while (bricks < 10 && attempts < 100) {
                    const change = (Math.random() - 0.5) * brickSize * 2;
                    currentPrice += change;
                    if (Math.abs(change) >= brickSize) {
                        data.push(currentPrice);
                        bricks++;
                    } else {
                        data.push(null);
                    }
                    attempts++;
                }
                // If still not enough, fill with last price
                while (bricks < 10) {
                    data.push(currentPrice);
                    bricks++;
                }
                const filtered = data.filter(val => val !== null);
                return {
                    label: 'Renko',
                    data: filtered,
                    backgroundColor: filtered.map((val, i, arr) => 
                        i > 0 && val > arr[i-1] ? '#00ff88' : '#ff4444'),
                    borderColor: filtered.map((val, i, arr) => 
                        i > 0 && val > arr[i-1] ? '#00ff88' : '#ff4444'),
                    borderWidth: 1,
                    barThickness: 12
                };
            }

            getTickData() {
                const basePrice = this.marketData[this.currentSymbol].price;
                const data = [];
                let currentPrice = basePrice;
                
                // Generate more frequent price changes for tick chart
                for (let i = 0; i < 50; i++) {
                    const change = (Math.random() - 0.5) * 1; // Smaller changes
                    currentPrice += change;
                    data.push(currentPrice);
                }
                
                return {
                    label: 'Tick',
                    data: data,
                    borderColor: '#00ffaa',
                    backgroundColor: this.createGradient(this.chart.ctx, this.chart.canvas),
                    borderWidth: 1,
                    fill: false,
                    tension: 0.1,
                    pointRadius: 1
                };
            }

            createLineChart() {
                console.log('Creating line chart...');
                const ctx = document.getElementById('tradingChart').getContext('2d');
                
                // Generate price data
                const priceData = this.generatePriceData();
                const labels = priceData.map((_, index) => `${index + 1}m`);
                
                // Create gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.clientHeight);
                gradient.addColorStop(0, 'rgba(0, 255, 170, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 255, 170, 0.05)');

                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: this.currentSymbol,
                            data: priceData,
                            borderColor: 'var(--accent)',
                            backgroundColor: gradient,
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4,
                            pointBackgroundColor: 'var(--accent)',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2,
                            pointRadius: 4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            x: {
                                grid: { color: 'rgba(0, 255, 170, 0.2)' },
                                ticks: { color: '#e0e0e0' }
                            },
                            y: {
                                grid: { color: 'rgba(0, 255, 170, 0.2)' },
                                ticks: { 
                                    color: '#e0e0e0',
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        },
                        animation: {
                            duration: 1000,
                            easing: 'easeInOutQuart'
                        }
                    }
                });
                
                console.log('Line chart created successfully');
            }

            createSimpleCandlesticks() {
                console.log('Creating simple candlesticks...');
                const ctx = document.getElementById('tradingChart').getContext('2d');
                
                // Simple data that definitely works
                const labels = [];
                const data = [];
                const colors = [];
                
                let price = this.marketData[this.currentSymbol].price;
                
                for (let i = 0; i < 12; i++) {
                    const change = (Math.random() - 0.5) * 15;
                    price = Math.max(50, price + change);
                    
                    labels.push(`${i + 1}m`);
                    data.push(price);
                    colors.push(change >= 0 ? '#00FF00' : '#FF0000');
                }
                
                // Create chart exactly like the working version
                this.chart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Price',
                            data: data,
                            backgroundColor: colors.map(c => c + '80'),
                            borderColor: colors,
                            borderWidth: 1,
                            barThickness: 10
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            x: {
                                grid: { color: 'rgba(0, 255, 170, 0.2)' },
                                ticks: { color: '#e0e0e0' }
                            },
                            y: {
                                grid: { color: 'rgba(0, 255, 170, 0.2)' },
                                ticks: { 
                                    color: '#e0e0e0',
                                    callback: function(value) {
                                        return '$' + Math.round(value);
                                    }
                                }
                            }
                        },
                        animation: {
                            duration: 500
                        }
                    }
                });
                
                console.log('Candlestick chart created successfully');
            }

            createCandlestickChart(chartCanvas) {
                console.log('Creating candlestick chart...');
                
                // Generate candlestick data
                const candleData = [];
                const labels = [];
                const colors = [];
                let price = this.marketData[this.currentSymbol].price;
                
                for (let i = 0; i < 20; i++) {
                    const open = price;
                    const change = (Math.random() - 0.5) * 20;
                    const close = Math.max(1, open + change);
                    
                    candleData.push(close);
                    labels.push(`${i + 1}m`);
                    colors.push(close >= open ? '#00FF00' : '#FF0000');
                    price = close;
                }
                
                console.log('Generated candle data:', candleData.length, 'points');
                
                // Create chart
                const ctx = chartCanvas.getContext('2d');
                this.chart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Price',
                            data: candleData,
                            backgroundColor: colors.map(color => color + '80'),
                            borderColor: colors,
                            borderWidth: 2,
                            barThickness: 12
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            x: {
                                grid: { color: 'rgba(0, 255, 170, 0.2)' },
                                ticks: { color: '#e0e0e0' }
                            },
                            y: {
                                grid: { color: 'rgba(0, 255, 170, 0.2)' },
                                ticks: { 
                                    color: '#e0e0e0',
                                    callback: function(value) {
                                        return '$' + value.toFixed(0);
                                    }
                                }
                            }
                        },
                        animation: {
                            duration: 750
                        }
                    }
                });
                
                console.log('Candlestick chart created successfully:', !!this.chart);
                this.addActivity('âœ… Candlestick chart created!', 'system');
            }

            generateCandlestickData() {
                const basePrice = this.marketData[this.currentSymbol].price;
                const data = [];
                let lastClose = basePrice;
                
                for (let i = 0; i < 20; i++) {
                    const volatility = basePrice * 0.05; // 5% volatility
                    const open = lastClose;
                    const change = (Math.random() - 0.5) * volatility;
                    const close = Math.max(0.01, open + change);
                    const high = Math.max(open, close) + Math.random() * volatility * 0.3;
                    const low = Math.min(open, close) - Math.random() * volatility * 0.3;
                    
                    data.push({
                        time: `${i + 1}`,
                        open: Number(open.toFixed(2)),
                        high: Number(Math.max(high, 0.01).toFixed(2)),
                        low: Number(Math.max(low, 0.01).toFixed(2)),
                        close: Number(close.toFixed(2))
                    });
                    
                    lastClose = close;
                }
                
                return data;
            }

            resetToLineChart() {
                const chartCanvas = document.getElementById('tradingChart');
                const lightweightDiv = document.getElementById('lightweightChart');
                const lineBtn = document.querySelector('[data-chart="line"]');
                const candleBtn = document.querySelector('[data-chart="candlestick"]');
                
                // Show line chart, hide candlestick
                chartCanvas.style.display = 'block';
                lightweightDiv.style.display = 'none';
                
                // Update button states
                if (lineBtn && candleBtn) {
                    lineBtn.classList.add('active');
                    candleBtn.classList.remove('active');
                }
                
                console.log('Reset to line chart');
            }

            updateLightweightChart() {
                // Chart.js only implementation - no Lightweight Charts needed
                console.log('Using Chart.js for chart updates');
            }

            forceChartBlackBackground() {
                console.log('Forcing chart black background...');
                
                // Force background via chart API options if available
                if (this.lightweightChart && typeof this.lightweightChart.applyOptions === 'function') {
                    try {
                        this.lightweightChart.applyOptions({
                            layout: {
                                backgroundColor: '#000000',
                                textColor: '#e0e0e0',
                            }
                        });
                        console.log('Applied black background via chart API');
                    } catch (e) {
                        console.warn('Could not apply background via chart API:', e);
                    }
                }
                
                // Force background via CSS with setTimeout to ensure DOM is ready
                setTimeout(() => {
                    const container = document.getElementById('lightweightChart');
                    if (container) {
                        container.style.backgroundColor = '#000000';
                        container.style.setProperty('background-color', '#000000', 'important');
                        
                        // Force all child elements to have black background
                        const allElements = container.querySelectorAll('*');
                        allElements.forEach(el => {
                            if (el.tagName === 'CANVAS' || el.tagName === 'DIV') {
                                el.style.backgroundColor = '#000000';
                                el.style.setProperty('background-color', '#000000', 'important');
                            }
                        });
                        
                        console.log('Applied black background via CSS to container and children');
                    }
                }, 100);
                
                // Additional timeout for stubborn elements
                setTimeout(() => {
                    const container = document.getElementById('lightweightChart');
                    if (container) {
                        const canvases = container.querySelectorAll('canvas');
                        canvases.forEach(canvas => {
                            canvas.style.backgroundColor = '#000000';
                            canvas.style.setProperty('background-color', '#000000', 'important');
                        });
                        console.log('Applied black background to canvases');
                    }
                }, 500);
            }

            testCandlestickChart() {
                console.log('=== TESTING CANDLESTICK CHART ===');
                this.addActivity('ðŸ”§ Testing candlestick chart display...', 'system');
                
                // Force switch to candlestick chart
                this.switchChartType('candlestick');
                
                // Wait a bit then generate test data
                setTimeout(() => {
                    if (this.candlestickSeries) {
                        console.log('Creating VERY OBVIOUS test candlestick data...');
                        const testData = [];
                        let baseTime = Math.floor(Date.now() / 1000) - (50 * 86400); // 50 days ago in seconds
                        
                        // Create 50 VERY obvious candles with massive movements
                        for (let i = 0; i < 50; i++) {
                            const open = 100 + (i * 2); // Start at 100, increase by 2 each day
                            const isUp = i % 2 === 0; // Alternate up/down candles
                            const close = isUp ? open + 10 : open - 10; // HUGE 10-point movements
                            const high = Math.max(open, close) + 5; // 5 points above
                            const low = Math.min(open, close) - 5; // 5 points below
                            
                            testData.push({
                                time: baseTime + (i * 86400), // Daily candles
                                open: Number(open.toFixed(2)),
                                high: Number(high.toFixed(2)),
                                low: Number(low.toFixed(2)),
                                close: Number(close.toFixed(2))
                            });
                            
                            console.log(`Candle ${i}: O:${open} H:${high} L:${low} C:${close} ${isUp ? 'UP' : 'DOWN'}`);
                        }
                        
                        console.log('Total test data points:', testData.length);
                        console.log('First candle:', testData[0]);
                        console.log('Last candle:', testData[testData.length - 1]);
                        console.log('Price range:', testData[0].low, 'to', testData[testData.length - 1].high);
                        
                        // Set the data
                        this.candlestickSeries.setData(testData);
                        
                        // Force chart visibility and resize
                        const container = document.getElementById('lightweightChart');
                        const chartCanvas = document.getElementById('tradingChart');
                        
                        if (container && chartCanvas) {
                            chartCanvas.style.display = 'none';
                            container.style.display = 'block';
                            container.style.visibility = 'visible';
                            container.style.opacity = '1';
                            
                            // Ensure chart is properly sized
                            if (this.lightweightChart) {
                                const rect = container.getBoundingClientRect();
                                console.log('Final container dimensions:', rect.width, 'x', rect.height);
                                
                                this.lightweightChart.applyOptions({
                                    width: Math.floor(rect.width),
                                    height: Math.floor(rect.height),
                                    layout: {
                                        backgroundColor: '#000000',
                                        textColor: '#ffffff',
                                    },
                                    grid: {
                                        vertLines: {
                                            color: 'rgba(255, 255, 255, 0.1)',
                                        },
                                        horzLines: {
                                            color: 'rgba(255, 255, 255, 0.1)',
                                        },
                                    },
                                });
                                
                                // Fit all content to view
                                this.lightweightChart.timeScale().fitContent();
                                
                                // Force visible range for price scale
                                this.lightweightChart.priceScale('right').applyOptions({
                                    autoScale: true,
                                });
                                
                                // Force time scale to show all data
                                this.lightweightChart.timeScale().setVisibleRange({
                                    from: baseTime,
                                    to: baseTime + (50 * 86400)
                                });
                                
                                console.log('Forced visible range and auto-scaling');
                                
                                // Check if series has data
                                console.log('Candlestick series after data set:', this.candlestickSeries);
                                
                                // Apply more visible series options
                                this.candlestickSeries.applyOptions({
                                    upColor: '#00ff00',       // Pure bright green
                                    downColor: '#ff0000',     // Pure bright red  
                                    borderDownColor: '#ff0000',
                                    borderUpColor: '#00ff00',
                                    wickDownColor: '#ff0000',
                                    wickUpColor: '#00ff00',
                                    priceLineVisible: true,
                                    lastValueVisible: true,
                                });
                                
                                console.log('Chart resized and data applied');
                            }
                        }
                        
                        this.addActivity('âœ… Test candlestick chart with OBVIOUS data applied', 'system');
                        this.addActivity(`ðŸ“Š Data range: ${testData[0].low} to ${testData[testData.length - 1].high}`, 'system');
                        console.log('=== CANDLESTICK TEST COMPLETE ===');
                    } else {
                        this.addActivity('âŒ Candlestick series not available for testing', 'system');
                        console.error('No candlestick series available');
                    }
                }, 1000);
            }

            generatePriceData() {
                const basePrice = this.marketData[this.currentSymbol].price;
                const data = [];
                let currentPrice = basePrice;

                for (let i = 0; i < 50; i++) {
                    const change = (Math.random() - 0.5) * 2;
                    currentPrice += change;
                    data.push(currentPrice);
                }

                return data;
            }

            updateChart() {
                const newData = this.generatePriceData();
                this.chart.data.datasets[0].data = newData;
                this.chart.update('none');
            }

            initializeAudio() {
                this.audioContext = null;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Audio context not supported');
                }
            }

            playAudio(type, force = false) {
                // Check if audio is enabled or if it's a forced play (like test buttons)
                if (!force && (!this.config.audio.enabled || !this.audioContext)) return;

                // Map audio types to specific sounds
                const audioMap = {
                    'trade': 'tradeExecutedSound',
                    'alert': 'alertSound',
                    'success': 'successSound',
                    'error': 'errorSound',
                    'start': 'startSound',
                    'stop': 'stopSound'
                };

                const audioElementId = audioMap[type] || 'alertSound';
                const audioElement = document.getElementById(audioElementId);
                
                if (audioElement) {
                    audioElement.volume = this.config.audio.volume;
                    audioElement.currentTime = 0; // Reset to beginning
                    audioElement.play().catch(e => {
                        console.warn('Audio play failed:', e);
                        // Fallback to Web Audio API beep if HTML5 audio fails
                        this.createBeep(this.getFrequencyForType(type), 200);
                    });
                } else {
                    // Fallback to Web Audio API beep
                    this.createBeep(this.getFrequencyForType(type), 200);
                }

                // Also create a beep using Web Audio API for enhanced notification
                if (this.audioContext) {
                    this.createBeep(this.getFrequencyForType(type), 150);
                }
            }

            getFrequencyForType(type) {
                const frequencies = {
                    'trade': 800,    // High pitch for trades
                    'alert': 400,    // Medium pitch for alerts
                    'success': 600,  // Pleasant tone for success
                    'error': 200,    // Low pitch for errors
                    'start': 700,    // Rising tone for start
                    'stop': 300      // Falling tone for stop
                };
                return frequencies[type] || 400;
            }

            createBeep(frequency, duration) {
                if (!this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration / 1000);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration / 1000);
            }

            showPnLNotification(pnl) {
                if (pnl === undefined) return;
                
                const notification = document.createElement('div');
                notification.className = `pnl-notification ${pnl >= 0 ? 'profit' : 'loss'}`;
                notification.innerHTML = `
                    <i class="fas fa-${pnl >= 0 ? 'arrow-up' : 'arrow-down'}"></i>
                    $${Math.abs(pnl).toFixed(2)}
                `;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.opacity = '1';
                    notification.style.transform = 'translateY(0)';
                }, 10);
                
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => notification.remove(), 500);
                }, 3000);
            }

            startDataStream() {
                // Simulate real-time market data
                setInterval(() => {
                    this.updateMarketData();
                    if (this.isRunning) {
                        this.updateChart();
                    }
                }, 2000);

                // Update connection status periodically
                setInterval(() => {
                    this.updateConnectionStatus();
                }, 5000);
            }

            updateMarketData() {
                Object.keys(this.marketData).forEach(symbol => {
                    const change = (Math.random() - 0.5) * 0.5;
                    this.marketData[symbol].price += change;
                    this.marketData[symbol].change += change;
                });
            }

            async startTrading() {
                if (this.isRunning) return;

                this.isRunning = true;
                this.emergencyStopActive = false;
                this.updateStatusBar();
                this.updateActivityIndicator();
                
                // Update UI
                document.getElementById('connectionText').textContent = 'Trading Active';
                document.getElementById('statusDot').style.background = 'var(--positive)';
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;

                this.addActivity('ðŸš€ Trading bot started successfully', 'system');
                this.addActivity('ðŸ“Š Monitoring market conditions', 'system');
                this.playAudio('alert');

                // Start trading cycle
                this.tradingInterval = setInterval(() => {
                    this.executeTradingCycle();
                }, 5000 + Math.random() * 10000); // Random interval between 5-15 seconds

                // Send Telegram notification
                this.sendTelegramMessage('ðŸ¤– IQTS Bot trading started!');
            }

            stopTrading() {
                if (!this.isRunning) return;

                this.isRunning = false;
                this.emergencyStopActive = false;
                clearInterval(this.tradingInterval);
                this.updateStatusBar();
                this.updateActivityIndicator();
                
                // Update UI
                document.getElementById('connectionText').textContent = 'Bot Stopped';
                document.getElementById('statusDot').style.background = 'var(--warning)';
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;

                this.addActivity('â¹ï¸ Trading bot stopped', 'system');

                // Send Telegram notification
                this.sendTelegramMessage('â¹ï¸ IQTS Bot trading stopped');
            }

            emergencyStop() {
                this.isRunning = false;
                this.emergencyStopActive = true;
                clearInterval(this.tradingInterval);
                this.updateStatusBar();
                this.updateActivityIndicator();
                
                // Update UI with emergency state
                document.getElementById('connectionText').textContent = 'EMERGENCY STOP';
                document.getElementById('statusDot').style.background = 'var(--negative)';
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                
                // Close all positions (simulation)
                this.positions.forEach(position => {
                    this.closePosition(position);
                });

                this.addActivity('ðŸš¨ EMERGENCY STOP ACTIVATED', 'system');
                this.addActivity('ðŸ›‘ All trading operations halted', 'system');
                this.playAudio('alert');
                this.sendTelegramMessage('ðŸš¨ EMERGENCY STOP ACTIVATED - All positions closed!');
                
                // Try to close all positions via Alpaca if connected
                if (this.alpacaAPI) {
                    this.alpacaAPI.closeAllPositions().catch(error => {
                        this.addActivity(`âŒ Error closing positions: ${error.message}`, 'system');
                    });
                    this.alpacaAPI.cancelAllOrders().catch(error => {
                        this.addActivity(`âŒ Error canceling orders: ${error.message}`, 'system');
                    });
                }
                
                // Reset emergency state after 10 seconds
                setTimeout(() => {
                    this.emergencyStopActive = false;
                    this.updateStatusBar();
                    if (!this.isRunning) {
                        document.getElementById('connectionText').textContent = 'Connecting...';
                        document.getElementById('statusDot').style.background = 'var(--accent)';
                    }
                }, 10000);
            }

            async executeTradingCycle() {
                if (!this.isRunning) return;

                // AI decision making simulation
                const symbols = Object.keys(this.marketData);
                const randomSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                const marketData = this.marketData[randomSymbol];
                
                // Simple trading logic based on price movement and risk level
                const shouldTrade = Math.random() < (this.riskLevel / 10) * 0.3;
                
                if (shouldTrade) {
                    const action = Math.random() > 0.5 ? 'BUY' : 'SELL';
                    const quantity = Math.floor(Math.random() * 10) + 1;
                    const price = marketData.price;
                    
                    if (action === 'BUY') {
                        if (this.alpacaConnected) {
                            this.executeRealBuy(randomSymbol, quantity);
                        } else {
                            this.executeBuy(randomSymbol, quantity, price);
                        }
                    } else if (this.positions.length > 0) {
                        if (this.alpacaConnected) {
                            this.executeRealSell(randomSymbol, quantity);
                        } else {
                            this.executeSell(randomSymbol, quantity, price);
                        }
                    }
                }
            }

            executeBuy(symbol, quantity, price) {
                const position = {
                    id: Date.now(),
                    symbol,
                    quantity,
                    price,
                    side: 'long',
                    timestamp: new Date(),
                    unrealizedPnL: 0
                };

                this.positions.push(position);
                this.trades.push({...position, action: 'BUY'});
                
                this.addActivity(`BUY ${quantity} ${symbol} @ $${price.toFixed(2)}`, 'buy');
                this.playAudio('trade');
                this.updateActivityIndicator();
                this.updatePositions();
                this.updateMetrics();

                // Send Telegram notification
                this.sendTelegramMessage(`ðŸ“ˆ BUY: ${quantity} ${symbol} @ $${price.toFixed(2)}`);
            }

            executeSell(symbol, quantity, price) {
                // Find matching position to close
                const positionIndex = this.positions.findIndex(p => p.symbol === symbol);
                if (positionIndex === -1) return;

                const position = this.positions[positionIndex];
                const pnl = (price - position.price) * Math.min(quantity, position.quantity);
                
                this.totalPnL += pnl;
                this.dailyPnL += pnl;

                if (quantity >= position.quantity) {
                    this.positions.splice(positionIndex, 1);
                } else {
                    position.quantity -= quantity;
                }

                this.trades.push({
                    id: Date.now(),
                    symbol,
                    quantity,
                    price,
                    side: 'short',
                    timestamp: new Date(),
                    action: 'SELL',
                    pnl
                });

                this.addActivity(`SELL ${quantity} ${symbol} @ $${price.toFixed(2)} (P&L: ${pnl > 0 ? '+' : ''}$${pnl.toFixed(2)})`, 'sell');
                this.playAudio('trade');
                
                // Show animated PnL notification
                this.showPnLNotification(pnl);
                
                // Update trade loss flag for activity indicator
                if (pnl < 0) {
                    this.lastTradeWasLoss = true;
                }
                this.updateActivityIndicator();
                this.updatePositions();
                this.updateMetrics();

                // Send Telegram notification
                const pnlText = pnl > 0 ? `ðŸ’° +$${pnl.toFixed(2)}` : `ðŸ“‰ -$${Math.abs(pnl).toFixed(2)}`;
                this.sendTelegramMessage(`ðŸ“‰ SELL: ${quantity} ${symbol} @ $${price.toFixed(2)} ${pnlText}`);
            }

            closePosition(position) {
                const currentPrice = this.marketData[position.symbol].price;
                this.executeSell(position.symbol, position.quantity, currentPrice);
            }

            updatePositions() {
                const grid = document.getElementById('positionsGrid');
                
                if (this.positions.length === 0) {
                    grid.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No active positions</div>';
                    document.getElementById('positionsCount').textContent = '0';
                    return;
                }

                document.getElementById('positionsCount').textContent = this.positions.length;

                grid.innerHTML = this.positions.map(position => {
                    const currentPrice = this.marketData[position.symbol].price;
                    const unrealizedPnL = (currentPrice - position.price) * position.quantity;
                    const pnlClass = unrealizedPnL >= 0 ? 'profit' : 'loss';
                    
                    // Position health indicator styles
                    const borderColor = unrealizedPnL >= 0 ? 'var(--positive)' : 'var(--negative)';
                    const backgroundOpacity = Math.min(0.1, Math.abs(unrealizedPnL)/500);
                    const backgroundGradient = unrealizedPnL >= 0 
                        ? `linear-gradient(90deg, rgba(0,255,170,${backgroundOpacity}) 0%, rgba(20,20,40,0.9) 30%)`
                        : `linear-gradient(90deg, rgba(255,85,85,${backgroundOpacity}) 0%, rgba(20,20,40,0.9) 30%)`;

                    return `
                        <div class="position-card" style="border-left: 4px solid ${borderColor}; background: ${backgroundGradient};">
                            <div class="position-header">
                                <span class="symbol">${position.symbol}</span>
                                <span class="profit-loss ${pnlClass}">
                                    ${unrealizedPnL >= 0 ? '+' : ''}$${unrealizedPnL.toFixed(2)}
                                </span>
                            </div>
                            <div style="display: flex; justify-content: between; font-size: 0.9rem; color: var(--text-secondary);">
                                <span>${position.quantity} shares @ $${position.price.toFixed(2)}</span>
                                <span style="margin-left: auto;">$${currentPrice.toFixed(2)}</span>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            updateMetrics() {
                document.getElementById('totalPnL').textContent = `${this.totalPnL >= 0 ? '+' : ''}$${this.totalPnL.toFixed(2)}`;
                document.getElementById('totalPnL').style.color = this.totalPnL >= 0 ? 'var(--positive)' : 'var(--negative)';
                
                document.getElementById('dailyPnL').textContent = `${this.dailyPnL >= 0 ? '+' : ''}$${this.dailyPnL.toFixed(2)}`;
                document.getElementById('dailyPnL').style.color = this.dailyPnL >= 0 ? 'var(--positive)' : 'var(--negative)';
                
                const winningTrades = this.trades.filter(t => t.pnl && t.pnl > 0).length;
                const totalClosedTrades = this.trades.filter(t => t.pnl !== undefined).length;
                this.winRate = totalClosedTrades > 0 ? (winningTrades / totalClosedTrades * 100) : 0;
                
                document.getElementById('winRate').textContent = `${this.winRate.toFixed(1)}%`;
                document.getElementById('totalTrades').textContent = this.trades.length;
            }

            addActivity(message, type = 'system') {
                const log = document.getElementById('activityLog');
                const time = new Date().toLocaleTimeString();
                
                const activityItem = document.createElement('div');
                activityItem.className = `activity-item ${type}`;
                activityItem.innerHTML = `
                    <span>${message}</span>
                    <span class="activity-time">${time}</span>
                `;
                
                log.insertBefore(activityItem, log.firstChild);
                
                // Keep only last 50 items
                while (log.children.length > 50) {
                    log.removeChild(log.lastChild);
                }

                // Auto-scroll to top only if user is already at the top
                if (log.scrollTop === 0) {
                    log.scrollTop = 0;
                }
            }

            clearActivityLog() {
                document.getElementById('activityLog').innerHTML = '';
            }

            async connectAlpaca() {
                const apiKey = document.getElementById('alpacaKeyId').value.trim();
                const secretKey = document.getElementById('alpacaSecret').value.trim();
                const paperTrading = document.getElementById('paperTrading').checked;

                if (!apiKey || !secretKey) {
                    this.showNotification('Please enter both API Key ID and Secret Key', 'error');
                    return;
                }

                this.config.alpaca.apiKey = apiKey;
                this.config.alpaca.secretKey = secretKey;
                this.config.alpaca.paperTrading = paperTrading;

                // Initialize Alpaca API
                this.alpacaAPI = new AlpacaAPI(this.config.alpaca);

                try {
                    // Test connection by getting account info
                    const account = await this.alpacaAPI.getAccount();
                    this.alpacaConnected = true;
                    
                    this.addActivity(`Alpaca connected: ${paperTrading ? 'Paper' : 'Live'} Trading`, 'system');
                    this.showNotification('Alpaca API connected successfully!', 'success');
                    
                    // Update real market data
                    this.startRealMarketData();
                    
                } catch (error) {
                    this.alpacaConnected = false;
                    this.showNotification('Failed to connect to Alpaca API', 'error');
                    console.error('Alpaca connection error:', error);
                }
            }

            async connectTelegram() {
                const botToken = document.getElementById('botToken').value.trim();
               
                const chatId = document.getElementById('chatId').value.trim();

                if (!botToken || !chatId) {
                    this.showNotification('Please enter both Bot Token and Chat ID', 'error');
                    return;
                }

                this.config.telegram.botToken = botToken;
                this.config.telegram.chatId = chatId;

                // Test connection
                try {
                    const testUrl = `https://api.telegram.org/bot${botToken}/getMe`;
                    const response = await fetch(testUrl);
                    
                    if (response.ok) {
                        this.telegramConnected = true;
                        this.showNotification('Telegram connected successfully!', 'success');
                        this.addActivity('Telegram bot connected successfully', 'system');
                        
                        // Update the connection label
                        const label = document.getElementById('telegramConnectedLabel');
                        label.innerHTML = '<i class="fab fa-telegram-plane" style="color: #00ffaa;"></i> Telegram: Connected';
                        label.style.color = '#00ffaa';
                        
                        // Update header status
                        document.getElementById('telegramStatus').textContent = 'Telegram: Connected';
                        
                        // Send test message
                        await this.sendTelegramMessage('ðŸ¤– IQTS Bot connected to Telegram successfully!');
                    } else {
                        throw new Error('Invalid bot token');
                    }
                } catch (error) {
                    this.telegramConnected = false;
                    this.showNotification('Failed to connect to Telegram', 'error');
                    console.error('Telegram connection error:', error);
                    
                    // Update the connection label
                    const label = document.getElementById('telegramConnectedLabel');
                    label.innerHTML = '<i class="fab fa-telegram-plane" style="color: #ff5555;"></i> Telegram: Connection Failed';
                    label.style.color = '#ff5555';
                }
            }

            async sendTelegramMessage(message) {
                if (!this.telegramConnected || !this.config.telegram.botToken || !this.config.telegram.chatId) {
                    return;
                }

                try {
                    const url = `https://api.telegram.org/bot${this.config.telegram.botToken}/sendMessage`;
                    await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            chat_id: this.config.telegram.chatId,
                            text: `ðŸ¤– IQTS Bot\n${message}\n\nâ° ${new Date().toLocaleString()}`,
                            parse_mode: 'HTML'
                        })
                    });
                } catch (error) {
                    console.error('Failed to send Telegram message:', error);
                }
            }

            updateConnectionStatus() {
                const statusDot = document.getElementById('statusDot');
                const connectionText = document.getElementById('connectionText');
                
                if (this.alpacaConnected) {
                    statusDot.style.background = 'var(--positive)';
                    const tradingMode = this.config.alpaca.paperTrading ? 'Paper' : 'Live';
                    connectionText.textContent = `Alpaca: Connected (${tradingMode})`;
                } else {
                    statusDot.style.background = 'var(--negative)';
                    connectionText.textContent = 'Alpaca: Disconnected';
                }
            }

            // Real market data integration
            async startRealMarketData() {
                if (!this.alpacaConnected || !this.alpacaAPI) return;

                try {
                    // Get real market data for current symbols
                    const symbols = Object.keys(this.marketData);
                    const quotes = await this.alpacaAPI.getLatestQuotes(symbols);
                    
                    // Update market data with real prices
                    Object.keys(quotes).forEach(symbol => {
                        if (this.marketData[symbol] && quotes[symbol]) {
                            this.marketData[symbol].price = quotes[symbol].ap; // Ask price
                            this.marketData[symbol].change = quotes[symbol].ap - quotes[symbol].bp; // Spread
                        }
                    });

                    this.addActivity('Real market data updated', 'system');
                } catch (error) {
                    console.error('Failed to get real market data:', error);
                }
            }

            // Real trading execution
            async executeRealBuy(symbol, quantity, orderType = 'market') {
                if (!this.alpacaConnected || !this.alpacaAPI) {
                    this.executeBuy(symbol, quantity, this.marketData[symbol].price);
                    return;
                }

                try {
                    const order = await this.alpacaAPI.createOrder({
                        symbol: symbol,
                        qty: quantity,
                        side: 'buy',
                        type: orderType,
                        time_in_force: 'day'
                    });

                    const position = {
                        id: order.id,
                        symbol,
                        quantity,
                        price: order.filled_avg_price || this.marketData[symbol].price,
                        side: 'long',
                        timestamp: new Date(),
                        orderId: order.id,
                        unrealizedPnL: 0
                    };

                    this.positions.push(position);
                    this.trades.push({...position, action: 'BUY'});
                    
                    this.addActivity(`REAL BUY ${quantity} ${symbol} @ $${position.price.toFixed(2)} (Order: ${order.id})`, 'buy');
                    this.playAudio('trade');
                    this.updatePositions();
                    this.updateMetrics();

                    // Send Telegram notification
                    this.sendTelegramMessage(`ðŸ“ˆ REAL BUY: ${quantity} ${symbol} @ $${position.price.toFixed(2)}\nOrder ID: ${order.id}`);

                } catch (error) {
                    console.error('Failed to execute real buy order:', error);
                    this.addActivity(`Failed to execute BUY order for ${symbol}: ${error.message}`, 'system');
                    this.showNotification('Failed to execute buy order', 'error');
                }
            }

            async executeRealSell(symbol, quantity, orderType = 'market') {
                if (!this.alpacaConnected || !this.alpacaAPI) {
                    this.executeSell(symbol, quantity, this.marketData[symbol].price);
                    return;
                }

                try {
                    const order = await this.alpacaAPI.createOrder({
                        symbol: symbol,
                        qty: quantity,
                        side: 'sell',
                        type: orderType,
                        time_in_force: 'day'
                    });

                    // Find matching position to close
                    const positionIndex = this.positions.findIndex(p => p.symbol === symbol);
                    if (positionIndex !== -1) {
                        const position = this.positions[positionIndex];
                        const sellPrice = order.filled_avg_price || this.marketData[symbol].price;
                        const pnl = (sellPrice - position.price) * Math.min(quantity, position.quantity);
                        
                        this.totalPnL += pnl;
                        this.dailyPnL += pnl;

                        if (quantity >= position.quantity) {
                            this.positions.splice(positionIndex, 1);
                        } else {
                            position.quantity -= quantity;
                        }

                        this.trades.push({
                            id: order.id,
                            symbol,
                            quantity,
                            price: sellPrice,
                            side: 'short',
                            timestamp: new Date(),
                            action: 'SELL',
                            orderId: order.id,
                            pnl
                        });

                        this.addActivity(`REAL SELL ${quantity} ${symbol} @ $${sellPrice.toFixed(2)} (P&L: ${pnl > 0 ? '+' : ''}$${pnl.toFixed(2)}) Order: ${order.id}`, 'sell');
                        this.playAudio('trade');
                        
                        // Show animated PnL notification for real trades too
                        this.showPnLNotification(pnl);
                        
                        this.updatePositions();
                        this.updateMetrics();

                        // Send Telegram notification
                        const pnlText = pnl > 0 ? `ðŸ’° +$${pnl.toFixed(2)}` : `ðŸ“‰ -$${Math.abs(pnl).toFixed(2)}`;
                        this.sendTelegramMessage(`ðŸ“‰ REAL SELL: ${quantity} ${symbol} @ $${sellPrice.toFixed(2)} ${pnlText}\nOrder ID: ${order.id}`);
                    }

                } catch (error) {
                    console.error('Failed to execute real sell order:', error);
                    this.addActivity(`Failed to execute SELL order for ${symbol}: ${error.message}`, 'system');
                    this.showNotification('Failed to execute sell order', 'error');
                }
            }

            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
                        <span>${message}</span>
                    </div>
                `;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 5000);
            }

            // ===== MARKET HOURS FEATURES =====

            updateMarketSessionIndicator() {
                const now = new Date();
                const hours = now.getHours();
                const minutes = now.getMinutes();
                const day = now.getDay(); // 0 = Sunday, 1 = Monday, etc.
                
                // Market hours (9:30 AM - 4:00 PM ET, Monday-Friday)
                const isWeekday = day >= 1 && day <= 5;
                const isHoliday = this.isMarketHoliday(now);
                const isPreMarket = isWeekday && !isHoliday && ((hours === 9 && minutes < 30) || hours < 9);
                const isMarketHours = isWeekday && !isHoliday && ((hours === 9 && minutes >= 30) || 
                                   (hours > 9 && hours < 16) || (hours === 16 && minutes === 0));
                const isAfterHours = isWeekday && !isHoliday && ((hours === 16 && minutes > 0) || hours > 16 || hours < 9);
                
                let status, color;
                if (!isWeekday || isHoliday) {
                    status = "Market Closed";
                    color = "var(--negative)";
                } else if (isPreMarket) {
                    status = "Pre-Market";
                    color = "var(--warning)";
                } else if (isMarketHours) {
                    status = "Market Open";
                    color = "var(--positive)";
                } else {
                    status = "After-Hours";
                    color = "var(--warning)";
                }
                
                // Update the market status indicator
                const indicator = document.getElementById('marketStatusIndicator');
                if (indicator) {
                    indicator.innerHTML = `
                        <span class="status-dot" style="background: ${color}; box-shadow: 0 0 10px ${color};"></span>
                        <span>${status}</span>
                    `;
                }
            }

            startMarketCountdownTimer() {
                setInterval(() => {
                    const now = new Date();
                    const nextOpen = this.getNextMarketOpen(now);
                    const nextClose = this.getNextMarketClose(now);
                    
                    const timeToOpen = nextOpen - now;
                    const timeToClose = nextClose - now;
                    
                    let countdownText = '';
                    let detailText = '';
                    
                    if (this.getMarketStatus() === 'Market Open') {
                        const hours = Math.floor(timeToClose / (1000 * 60 * 60));
                        const minutes = Math.floor((timeToClose % (1000 * 60 * 60)) / (1000 * 60));
                        const seconds = Math.floor((timeToClose % (1000 * 60)) / 1000);
                        
                        countdownText = `Closes in: ${hours}h ${minutes}m ${seconds}s`;
                        detailText = `Market closes at 4:00 PM ET today`;
                    } else {
                        const days = Math.floor(timeToOpen / (1000 * 60 * 60 * 24));
                        const hours = Math.floor((timeToOpen % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                        const minutes = Math.floor((timeToOpen % (1000 * 60 * 60)) / (1000 * 60));
                        const seconds = Math.floor((timeToOpen % (1000 * 60)) / 1000);
                        
                        if (days > 0) {
                            countdownText = `Opens in: ${days}d ${hours}h ${minutes}m`;
                            detailText = `Market opens 9:30 AM ET (${nextOpen.toLocaleDateString()})`;
                        } else {
                            countdownText = `Opens in: ${hours}h ${minutes}m ${seconds}s`;
                            detailText = `Market opens at 9:30 AM ET today`;
                        }
                    }
                    
                    // Update the dedicated countdown element
                    const countdownElement = document.getElementById('marketCountdown');
                    if (countdownElement) {
                        countdownElement.innerHTML = `
                            <i class="fas fa-clock"></i>
                            <div style="display: flex; flex-direction: column; align-items: flex-start;">
                                <span style="font-weight: 600;">${countdownText}</span>
                                <small style="font-size: 0.75rem; color: var(--text-secondary);">${detailText}</small>
                            </div>
                        `;
                    }
                    
                    // Update current time display
                    this.updateCurrentTime();
                }, 1000); // Update every second for real-time countdown
            }

            updateCurrentTime() {
                const timeElement = document.getElementById('currentTime');
                if (timeElement) {
                    const now = new Date();
                    const timeString = now.toLocaleTimeString('en-US', {
                        hour12: true,
                        hour: 'numeric',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                    const dateString = now.toLocaleDateString('en-US', {
                        weekday: 'short',
                        month: 'short',
                        day: 'numeric'
                    });
                    
                    timeElement.innerHTML = `
                        <i class="fas fa-clock"></i>
                        <div style="display: flex; flex-direction: column; align-items: flex-start;">
                            <span style="font-weight: 600; color: var(--accent);">${timeString}</span>
                            <small style="font-size: 0.75rem; color: var(--text-secondary);">${dateString}</small>
                        </div>
                    `;
                }
            }

            getNextMarketOpen(date) {
                let result = new Date(date);
                result.setHours(9, 30, 0, 0); // 9:30 AM
                
                // If it's a weekday but after hours, move to next day
                if (result <= date) {
                    result.setDate(result.getDate() + 1);
                }
                
                // Skip holidays and weekends
                while (this.isMarketHoliday(result)) {
                    result.setDate(result.getDate() + 1);
                }
                
                return result;
            }

            getNextMarketClose(date) {
                let result = new Date(date);
                result.setHours(16, 0, 0, 0); // 4:00 PM
                
                // If it's before market open today, use today's close
                if (result > date && !this.isMarketHoliday(result)) {
                    return result;
                }
                
                // Otherwise use next trading day's close
                do {
                    result.setDate(result.getDate() + 1);
                } while (this.isMarketHoliday(result));
                
                return result;
            }

            checkMarketHours() {
                const now = new Date();
                const hours = now.getHours();
                const minutes = now.getMinutes();
                const day = now.getDay();
                
                const isWeekday = day >= 1 && day <= 5;
                const isMarketHours = isWeekday && !this.isMarketHoliday(now) && 
                                     ((hours === 9 && minutes >= 30) || 
                                      (hours > 9 && hours < 16) || 
                                      (hours === 16 && minutes === 0));
                
                if (this.isRunning && !isMarketHours) {
                    this.stopTrading();
                    this.addActivity("Auto-paused: Outside market hours", "system");
                    if (this.telegramConnected) {
                        this.sendTelegramMessage("ðŸ”´ Trading auto-paused: Outside market hours");
                    }
                }
                
                // Run this check every 5 minutes
                setTimeout(() => this.checkMarketHours(), 5 * 60 * 1000);
            }

            isMarketHoliday(date) {
                const holidays = [
                    '01-01', // New Year's Day
                    '01-15', // MLK Day (3rd Monday, example date)
                    '02-19', // Presidents Day (3rd Monday, example date)
                    '05-27', // Memorial Day (last Monday, example date)
                    '07-04', // Independence Day
                    '09-02', // Labor Day (1st Monday, example date)
                    '11-28', // Thanksgiving (4th Thursday, example date)
                    '12-25'  // Christmas
                ];
                
                const dateStr = `${String(date.getMonth()+1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                return holidays.includes(dateStr) || date.getDay() === 0 || date.getDay() === 6;
            }

            getMarketStatus() {
                const now = new Date();
                const isHoliday = this.isMarketHoliday(now);
                const hours = now.getHours();
                const minutes = now.getMinutes();
                const day = now.getDay();
                
                const isWeekday = day >= 1 && day <= 5;
                const isMarketHours = isWeekday && !isHoliday && ((hours === 9 && minutes >= 30) || 
                                   (hours > 9 && hours < 16) || (hours === 16 && minutes === 0));
                
                if (isHoliday) return "Holiday";
                if (!isWeekday) return "Weekend";
                if (isMarketHours) return "Market Open";
                if (hours < 9 || (hours === 9 && minutes < 30)) return "Pre-Market";
                return "After-Hours";
            }

            startSystemMonitoring() {
                let startTime = Date.now();
                
                // Uptime counter
                setInterval(() => {
                    const uptimeSeconds = Math.floor((Date.now() - startTime) / 1000);
                    const hours = Math.floor(uptimeSeconds / 3600);
                    const minutes = Math.floor((uptimeSeconds % 3600) / 60);
                    const seconds = uptimeSeconds % 60;
                    
                    const uptimeElement = document.getElementById('uptimeCounter');
                    if (uptimeElement) {
                        uptimeElement.textContent = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    }
                }, 1000);
                
                // CPU/Memory monitoring (simulated in browser environment)
                setInterval(() => {
                    // Simulate CPU usage (0-100%) with more realistic patterns
                    const cpuUsage = Math.min(100, Math.max(0, 10 + Math.random() * 30));
                    const cpuElement = document.getElementById('cpuUsage');
                    if (cpuElement) {
                        cpuElement.textContent = `${cpuUsage.toFixed(1)}%`;
                        // Color coding for CPU usage
                        if (cpuUsage > 80) {
                            cpuElement.style.color = 'var(--negative)';
                        } else if (cpuUsage > 60) {
                            cpuElement.style.color = 'var(--warning)';
                        } else {
                            cpuElement.style.color = 'var(--positive)';
                        }
                    }
                    
                    // Simulate memory usage with more realistic values
                    const memoryUsed = 50 + Math.random() * 200;
                    const memoryElement = document.getElementById('memoryUsage');
                    if (memoryElement) {
                        memoryElement.textContent = `${memoryUsed.toFixed(0)} MB`;
                        // Color coding for memory usage
                        if (memoryUsed > 200) {
                            memoryElement.style.color = 'var(--negative)';
                        } else if (memoryUsed > 150) {
                            memoryElement.style.color = 'var(--warning)';
                        } else {
                            memoryElement.style.color = 'var(--positive)';
                        }
                    }
                    
                    // Generate performance suggestions
                    this.generatePerformanceSuggestions(cpuUsage, memoryUsed);
                }, 5000);
                
                // API latency monitoring - Real monitoring when Alpaca is connected
                setInterval(() => {
                    if (this.alpacaConnected && this.alpacaAPI) {
                        const start = performance.now();
                        this.alpacaAPI.getAccount().then(() => {
                            const latency = performance.now() - start;
                            const latencyElement = document.getElementById('apiLatency');
                            if (latencyElement) {
                                latencyElement.textContent = `${latency.toFixed(0)} ms`;
                                // Color coding for API latency
                                if (latency > 500) {
                                    latencyElement.style.color = 'var(--negative)';
                                } else if (latency > 200) {
                                    latencyElement.style.color = 'var(--warning)';
                                } else {
                                    latencyElement.style.color = 'var(--positive)';
                                }
                            }
                        }).catch(() => {
                            const latencyElement = document.getElementById('apiLatency');
                            if (latencyElement) {
                                latencyElement.textContent = "Error";
                                latencyElement.style.color = 'var(--negative)';
                            }
                        });
                    } else {
                        // Simulated latency when not connected
                        const latency = Math.floor(Math.random() * 100) + 50; // 50-150ms
                        const latencyElement = document.getElementById('apiLatency');
                        if (latencyElement) {
                            latencyElement.textContent = `${latency} ms (sim)`;
                            latencyElement.style.color = latency > 100 ? 'var(--warning)' : 'var(--positive)';
                        }
                    }
                }, 10000);
            }

            generatePerformanceSuggestions(cpuUsage, memoryUsed) {
                let suggestions = [];
                
                if (cpuUsage > 80) {
                    suggestions.push("âš ï¸ High CPU usage - consider reducing trading frequency");
                }
                
                if (cpuUsage > 90) {
                    suggestions.push("ðŸ”¥ Critical CPU usage - browser may become unresponsive");
                }
                
                if (memoryUsed > 200) {
                    suggestions.push("ðŸ’¾ High memory usage - browser may slow down");
                }
                
                if (memoryUsed > 300) {
                    suggestions.push("ðŸ”„ Consider refreshing the page to free memory");
                }
                
                if (this.isRunning && cpuUsage > 85) {
                    suggestions.push("â¸ï¸ Consider pausing trading to reduce system load");
                }
                
                if (!this.alpacaConnected) {
                    suggestions.push("ðŸ”Œ Connect to Alpaca for real API latency monitoring");
                }
                
                const suggestionText = suggestions.length > 0 ? 
                    suggestions.join("<br>") : "âœ… System performance normal";
                
                const suggestionsElement = document.getElementById('performanceSuggestions');
                if (suggestionsElement) {
                    suggestionsElement.innerHTML = suggestionText;
                }
            }

            setupPnLAlerts() {
                this.pnlAlertThresholds = {
                    positive: 100, // $100 profit
                    negative: -50  // $50 loss
                };
                
                // Check P&L every 5 minutes
                setInterval(() => {
                    if (!this.telegramConnected || !this.isRunning) return;
                    
                    const totalPnL = this.totalPnL;
                    const dailyPnL = this.dailyPnL;
                    
                    if (totalPnL >= this.pnlAlertThresholds.positive) {
                        this.addActivity(`ðŸŽ‰ Profit alert: $${totalPnL.toFixed(2)}`, 'system');
                        this.sendTelegramMessage(`ðŸŽ‰ Profit Alert! Total P&L reached $${totalPnL.toFixed(2)}`);
                        this.playAudio('success');
                        this.pnlAlertThresholds.positive += 100; // Next alert at next $100
                    }
                    
                    if (totalPnL <= this.pnlAlertThresholds.negative) {
                        this.addActivity(`âš ï¸ Loss alert: $${totalPnL.toFixed(2)}`, 'system');
                        this.sendTelegramMessage(`âš ï¸ Loss Alert! Total P&L dropped to $${totalPnL.toFixed(2)}`);
                        this.playAudio('alert');
                        this.pnlAlertThresholds.negative -= 50; // Next alert at next $50 loss
                    }
                }, 5 * 60 * 1000);
            }

            async sendTelegramMessage(message, chatId = null) {
                if (!this.telegramConnected || !this.config?.telegram?.botToken) return;
                
                const targetChatId = chatId || this.config.telegram.chatId;
                if (!targetChatId) return;
                
                try {
                    const url = `https://api.telegram.org/bot${this.config.telegram.botToken}/sendMessage`;
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            chat_id: targetChatId,
                            text: `ðŸ¤– IQTS Bot\n${message}\n\nâ° ${new Date().toLocaleString()}`,
                            parse_mode: 'HTML'
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Telegram API error: ${response.status}`);
                    }
                } catch (error) {
                    console.error('Failed to send Telegram message:', error);
                    this.addActivity('Failed to send Telegram message', 'system');
                }
            }

            // ===== ENHANCED TELEGRAM INTEGRATION =====

            setupTelegramCommands() {
                // This would need a webhook setup with your Telegram bot
                // Here's a simplified version that checks for commands periodically
                
                setInterval(async () => {
                    if (!this.telegramConnected) return;
                    
                    try {
                        const updatesUrl = `https://api.telegram.org/bot${this.config.telegram.botToken}/getUpdates`;
                        const response = await fetch(updatesUrl);
                        const data = await response.json();
                        
                        if (data.ok && data.result.length > 0) {
                            for (const update of data.result) {
                                if (update.message && update.message.text) {
                                    const command = update.message.text.toLowerCase();
                                    const chatId = update.message.chat.id;
                                    
                                    if (command === '/status') {
                                        this.sendTelegramMessage(
                                            `ðŸ¤– Bot Status:\n` +
                                            `Running: ${this.isRunning ? 'âœ…' : 'âŒ'}\n` +
                                            `Market: ${this.getMarketStatus()}\n` +
                                            `Positions: ${this.positions.length}\n` +
                                            `Today's P&L: $${this.dailyPnL.toFixed(2)}\n` +
                                            `Total P&L: $${this.totalPnL.toFixed(2)}\n` +
                                            `Risk Level: ${this.riskLevel}/10`,
                                            chatId
                                        );
                                    }
                                    else if (command === '/pause') {
                                        this.stopTrading();
                                        this.sendTelegramMessage("â¸ Trading paused via Telegram command", chatId);
                                        this.addActivity("Trading paused via Telegram", "system");
                                    }
                                    else if (command === '/resume') {
                                        this.startTrading();
                                        this.sendTelegramMessage("â–¶ Trading resumed via Telegram command", chatId);
                                        this.addActivity("Trading resumed via Telegram", "system");
                                    }
                                    else if (command === '/emergency') {
                                        this.emergencyStop();
                                        this.sendTelegramMessage("ðŸš¨ EMERGENCY STOP activated via Telegram!", chatId);
                                        this.addActivity("Emergency stop via Telegram", "system");
                                    }
                                    else if (command === '/positions') {
                                        const positionsText = this.positions.length > 0 ? 
                                            this.positions.map(p => `${p.symbol}: ${p.quantity} @ $${p.price}`).join('\n') :
                                            "No active positions";
                                        this.sendTelegramMessage(`ðŸ“Š Current Positions:\n${positionsText}`, chatId);
                                    }
                                    else if (command === '/help') {
                                        this.sendTelegramMessage(
                                            "ðŸ¤– Available Commands:\n" +
                                            "/status - Bot status & metrics\n" +
                                            "/pause - Pause trading\n" +
                                            "/resume - Resume trading\n" +
                                            "/emergency - Emergency stop\n" +
                                            "/positions - View positions\n" +
                                            "/report - Daily summary\n" +
                                            "/help - This message",
                                            chatId
                                        );
                                    }
                                    else if (command === '/report') {
                                        this.sendDailyReport();
                                    }
                                }
                            }
                            
                            // Mark updates as processed
                            const lastUpdateId = data.result[data.result.length - 1].update_id;
                            await fetch(`https://api.telegram.org/bot${this.config.telegram.botToken}/getUpdates?offset=${lastUpdateId + 1}`);
                        }
                    } catch (error) {
                        console.error("Telegram command error:", error);
                    }
                }, 10000); // Check every 10 seconds
            }

            setupScheduledReports() {
                // Hourly summary during market hours only
                setInterval(() => {
                    if (this.telegramConnected && this.isRunning && this.getMarketStatus() === "Market Open") {
                        const hourTrades = this.trades.filter(t => 
                            new Date(t.timestamp) > new Date(Date.now() - 60 * 60 * 1000));
                        
                        const hourPnL = hourTrades.reduce((sum, t) => sum + (t.pnl || 0), 0);
                        
                        const message = `ðŸ•’ Hourly Summary:\n` +
                            `Trades: ${hourTrades.length}\n` +
                            `Hour P&L: $${hourPnL.toFixed(2)}\n` +
                            `Active Positions: ${this.positions.length}\n` +
                            `Current Risk: ${this.riskLevel}/10`;
                        
                        this.sendTelegramMessage(message);
                        this.addActivity("Hourly report sent", "system");
                    }
                }, 60 * 60 * 1000); // Every hour
                
                // Daily summary at market close (4:30 PM) - skip weekends and holidays
                const scheduleNextDailyReport = () => {
                    const now = new Date();
                    const nextReport = new Date();
                    nextReport.setHours(16, 30, 0, 0);
                    
                    if (now > nextReport) {
                        nextReport.setDate(nextReport.getDate() + 1);
                    }
                    
                    // Skip weekends and holidays
                    while (this.isMarketHoliday(nextReport)) {
                        nextReport.setDate(nextReport.getDate() + 1);
                    }
                    
                    const timeUntilReport = nextReport - now;
                    setTimeout(() => {
                        this.sendDailyReport();
                        scheduleNextDailyReport(); // Schedule next one
                    }, timeUntilReport);
                };
                
                scheduleNextDailyReport();
                
                // Weekly summary on Friday after market close
                const scheduleWeeklyReport = () => {
                    const now = new Date();
                    const nextFriday = new Date();
                    const daysUntilFriday = (5 - now.getDay() + 7) % 7 || 7;
                    nextFriday.setDate(now.getDate() + daysUntilFriday);
                    nextFriday.setHours(16, 45, 0, 0);
                    
                    const timeUntilWeekly = nextFriday - now;
                    setTimeout(() => {
                        this.sendWeeklyReport();
                        scheduleWeeklyReport(); // Schedule next one
                    }, timeUntilWeekly);
                };
                
                scheduleWeeklyReport();
            }

            sendDailyReport() {
                if (!this.telegramConnected) return;
                
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const dailyTrades = this.trades.filter(t => new Date(t.timestamp) > today);
                
                const profitTrades = dailyTrades.filter(t => (t.pnl || 0) > 0);
                const lossTrades = dailyTrades.filter(t => (t.pnl || 0) < 0);
                const totalPnL = dailyTrades.reduce((sum, t) => sum + (t.pnl || 0), 0);
                const winRate = dailyTrades.length > 0 ? (profitTrades.length / dailyTrades.length * 100) : 0;
                
                const message = `ðŸ“Š Daily Trading Report:\n` +
                    `ðŸ“ˆ Total Trades: ${dailyTrades.length}\n` +
                    `âœ… Profitable: ${profitTrades.length}\n` +
                    `âŒ Loss Trades: ${lossTrades.length}\n` +
                    `ðŸŽ¯ Win Rate: ${winRate.toFixed(1)}%\n` +
                    `ðŸ’° Daily P&L: $${totalPnL.toFixed(2)}\n` +
                    `ðŸ“Š Total P&L: $${this.totalPnL.toFixed(2)}\n` +
                    `âš–ï¸ Risk Level: ${this.riskLevel}/10\n` +
                    `ðŸ”„ Active Positions: ${this.positions.length}`;
                
                this.sendTelegramMessage(message);
                this.addActivity("Daily report sent", "system");
            }

            sendWeeklyReport() {
                if (!this.telegramConnected) return;
                
                const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
                const weeklyTrades = this.trades.filter(t => new Date(t.timestamp) > weekAgo);
                
                const profitTrades = weeklyTrades.filter(t => (t.pnl || 0) > 0);
                const lossTrades = weeklyTrades.filter(t => (t.pnl || 0) < 0);
                const totalPnL = weeklyTrades.reduce((sum, t) => sum + (t.pnl || 0), 0);
                const winRate = weeklyTrades.length > 0 ? (profitTrades.length / weeklyTrades.length * 100) : 0;
                
                const message = `ðŸ“ˆ Weekly Trading Summary:\n` +
                    `ðŸ“Š Total Trades: ${weeklyTrades.length}\n` +
                    `âœ… Profitable: ${profitTrades.length}\n` +
                    `âŒ Loss Trades: ${lossTrades.length}\n` +
                    `ðŸŽ¯ Win Rate: ${winRate.toFixed(1)}%\n` +
                    `ðŸ’° Weekly P&L: $${totalPnL.toFixed(2)}\n` +
                    `ðŸ“ˆ Total P&L: $${this.totalPnL.toFixed(2)}\n` +
                    `âš–ï¸ Average Risk: ${this.riskLevel}/10`;
                
                this.sendTelegramMessage(message);
                this.addActivity("Weekly report sent", "system");
            }

            // Status Bar and Activity Indicator Methods
            createStatusBar() {
                // Status bar is already in HTML, just initialize
                this.updateStatusBar();
            }

            updateStatusBar() {
                const statusBar = document.getElementById('globalStatusBar');
                if (!statusBar) return;
                
                statusBar.classList.remove('active', 'emergency');
                
                if (this.emergencyStopActive) {
                    statusBar.classList.add('emergency');
                } else if (this.isRunning) {
                    statusBar.classList.add('active');
                }
            }

            updateActivityIndicator() {
                const indicator = document.getElementById('activityIndicator');
                if (!indicator) return;
                
                indicator.classList.remove('active', 'alert');
                
                if (this.isRunning) {
                    if (this.positions.length > 0) {
                        indicator.classList.add('active');
                    } else {
                        indicator.classList.remove('active');
                    }
                }
                
                // Add alert class if important event occurs
                if (this.lastTradeWasLoss) {
                    indicator.classList.add('alert');
                    setTimeout(() => {
                        indicator.classList.remove('alert');
                        this.lastTradeWasLoss = false;
                    }, 5000);
                }
            }

            // Enhanced trade execution with visual feedback
            executeTradeWithFeedback(tradeData) {
                // Update activity indicator based on trade result
                if (tradeData.profit < 0) {
                    this.lastTradeWasLoss = true;
                }
                
                this.updateActivityIndicator();
                
                // Add trade to activity log with enhanced formatting
                const profitClass = tradeData.profit >= 0 ? 'buy' : 'sell';
                this.addActivity(
                    `ðŸ’° ${tradeData.action} ${tradeData.symbol} - ${tradeData.profit >= 0 ? '+' : ''}$${tradeData.profit.toFixed(2)}`,
                    profitClass
                );
            }
        }

        // Panel toggle function
        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            const icon = document.getElementById(panelId + 'Icon');
            
            if (panel && icon) {
                if (panel.classList.contains('collapsed')) {
                    panel.classList.remove('collapsed');
                    icon.style.transform = 'rotate(0deg)';
                } else {
                    panel.classList.add('collapsed');
                    icon.style.transform = 'rotate(-90deg)';
                }
            }
        }

        // Initialize panel states
        function initializePanels() {
            // Start with panels collapsed for cleaner look
            const panels = ['audioPanel', 'alpacaPanel', 'telegramPanel'];
            panels.forEach(panelId => {
                const panel = document.getElementById(panelId);
                const icon = document.getElementById(panelId + 'Icon');
                if (panel && icon) {
                    panel.classList.add('collapsed');
                    icon.style.transform = 'rotate(-90deg)';
                }
            });
        }

        // Initialize the IQTS Bot when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize collapsible panels
            initializePanels();
            
            window.iqtsBot = new IQTSBot();
            
            // Add resize handler for better chart responsiveness
            window.addEventListener('resize', () => {
                if (window.iqtsBot && window.iqtsBot.chart) {
                    setTimeout(() => {
                        window.iqtsBot.chart.resize();
                    }, 100);
                }
                if (window.iqtsBot && window.iqtsBot.lightweightChart) {
                    setTimeout(() => {
                        window.iqtsBot.lightweightChart.resize();
                    }, 100);
                }
            });

            // Add keyboard shortcuts for enhanced control
            document.addEventListener('keydown', (e) => {
                if (!window.iqtsBot) return;
                
                // ESC key for emergency stop
                if (e.key === 'Escape') {
                    e.preventDefault();
                    window.iqtsBot.emergencyStop();
                }
                
                // Ctrl+S for start/stop trading
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    if (window.iqtsBot.isRunning) {
                        window.iqtsBot.stopTrading();
                    } else {
                        window.iqtsBot.startTrading();
                    }
                }
            });
            
            // Add keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    if (window.iqtsBot.isRunning) {
                        window.iqtsBot.stopTrading();
                    } else {
                        window.iqtsBot.startTrading();
                    }
                }
                
                if (e.key === 'Escape') {
                    window.iqtsBot.emergencyStop();
                }
            });

            // Add visual feedback for running state
            setInterval(() => {
                if (window.iqtsBot.isRunning) {
                    document.body.style.borderTop = '3px solid var(--accent)';
                } else {
                    document.body.style.borderTop = 'none';
                }
            }, 1000);
        });
    </script>
</body>
</html>
